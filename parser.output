Terminals unused in grammar

    UNKNOWN
    UMINUS
    LOWER_THAN_ELSE


Grammar

    0 $accept: program $end

    1 program: statement_list

    2 statement_list: ε
    3               | statement_list statement

    4 statement: declaration SEMI
    5          | assignment SEMI
    6          | if_stmt
    7          | while_stmt
    8          | for_stmt
    9          | switch_stmt
   10          | return_stmt SEMI
   11          | repeat_stmt
   12          | function_decl
   13          | const_decl SEMI
   14          | function_call SEMI
   15          | CONTINUE SEMI
   16          | BREAK SEMI
   17          | LBRACE statement_list RBRACE
   18          | declaration error
   19          | assignment error
   20          | return_stmt error
   21          | const_decl error
   22          | function_call error
   23          | CONTINUE error
   24          | BREAK error

   25 declaration: TYPE identifier_list
   26            | TYPE IDENTIFIER ASSIGN expression
   27            | TYPE error
   28            | TYPE IDENTIFIER ASSIGN error

   29 identifier_list: IDENTIFIER
   30                | identifier_list COMMA IDENTIFIER
   31                | identifier_list COMMA error

   32 assignment: IDENTIFIER INC
   33           | IDENTIFIER DEC
   34           | INC IDENTIFIER
   35           | DEC IDENTIFIER
   36           | IDENTIFIER ASSIGN expression
   37           | IDENTIFIER ASSIGN error

   38 @1: ε

   39 $@2: ε

   40 $@3: ε

   41 if_stmt: IF LPAREN expression RPAREN @1 LBRACE $@2 statement_list RBRACE $@3 else_part
   42        | IF error
   43        | IF LPAREN expression error
   44        | IF LPAREN expression RPAREN error

   45 $@4: ε

   46 else_part: ELSE LBRACE $@4 statement_list RBRACE
   47          | ELSE if_stmt
   48          | ε

   49 $@5: ε

   50 $@6: ε

   51 while_stmt: WHILE while_header LPAREN expression $@5 RPAREN LBRACE $@6 statement_list RBRACE
   52           | WHILE while_header error

   53 $@7: ε

   54 while_stmt: WHILE while_header LPAREN expression error LBRACE $@7 statement_list RBRACE

   55 while_header: ε

   56 for_stmt: FOR LPAREN for_header assignment RPAREN for_body
   57         | FOR error for_header assignment RPAREN for_body
   58         | FOR LPAREN for_header assignment error

   59 for_header: for_stmt_declaration SEMI expression SEMI
   60           | for_stmt_declaration error expression SEMI
   61           | for_stmt_declaration SEMI expression error

   62 $@8: ε

   63 for_body: LBRACE $@8 statement_list RBRACE

   64 for_stmt_declaration: TYPE IDENTIFIER ASSIGN expression
   65                     | TYPE IDENTIFIER
   66                     | IDENTIFIER ASSIGN expression
   67                     | TYPE error
   68                     | TYPE IDENTIFIER ASSIGN error
   69                     | IDENTIFIER ASSIGN error

   70 CONSTANT_VAL: INT
   71             | FLOAT
   72             | BOOLEAN
   73             | IDENTIFIER

   74 @9: ε

   75 $@10: ε

   76 switch_stmt: SWITCH LPAREN IDENTIFIER RPAREN @9 LBRACE $@10 case_list default_case RBRACE
   77            | SWITCH error
   78            | SWITCH LPAREN IDENTIFIER error
   79            | SWITCH LPAREN IDENTIFIER RPAREN error

   80 case_list: ε
   81          | case_list case_item

   82 @11: ε

   83 case_item: CASE CONSTANT_VAL COLON @11 statement_list
   84          | CASE CONSTANT_VAL error
   85          | CASE error

   86 $@12: ε

   87 default_case: DEFAULT COLON $@12 statement_list
   88             | DEFAULT error
   89             | ε

   90 return_stmt: RETURN expression
   91            | RETURN

   92 expression: logical_expr

   93 logical_expr: logical_expr OR logical_term
   94             | logical_term

   95 logical_term: logical_term AND equality_expr
   96             | equality_expr

   97 equality_expr: equality_expr EQ relational_expr
   98              | equality_expr NEQ relational_expr
   99              | relational_expr

  100 relational_expr: relational_expr LT additive_expr
  101                | relational_expr GT additive_expr
  102                | relational_expr LTE additive_expr
  103                | relational_expr GTE additive_expr
  104                | additive_expr

  105 additive_expr: additive_expr PLUS multiplicative_expr
  106              | additive_expr MINUS multiplicative_expr
  107              | multiplicative_expr

  108 multiplicative_expr: multiplicative_expr MUL exponent_expr
  109                    | multiplicative_expr DIV exponent_expr
  110                    | multiplicative_expr MOD exponent_expr
  111                    | exponent_expr

  112 exponent_expr: exponent_expr EXP unary_expr
  113              | unary_expr

  114 unary_expr: MINUS unary_expr
  115           | NOT unary_expr
  116           | primary_expr

  117 primary_expr: INT
  118             | FLOAT
  119             | CHAR
  120             | BOOLEAN
  121             | STRING
  122             | LPAREN expression RPAREN
  123             | function_call
  124             | IDENTIFIER

  125 @13: ε

  126 repeat_stmt: REPEAT LBRACE @13 statement_list RBRACE UNTIL LPAREN expression RPAREN SEMI

  127 $@14: ε

  128 function_decl: FUNCTION TYPE IDENTIFIER LPAREN params RPAREN LBRACE $@14 statement_list RBRACE

  129 function_call: IDENTIFIER LPAREN argument_list RPAREN
  130              | IDENTIFIER LPAREN RPAREN
  131              | IDENTIFIER LPAREN error

  132 argument_list: argument_list COMMA expression
  133              | expression

  134 params: ε
  135       | param_list

  136 param_list: param_list COMMA param
  137           | param

  138 param: TYPE IDENTIFIER

  139 const_decl: CONST TYPE IDENTIFIER ASSIGN expression


Terminals, with rules where they appear

    $end (0) 0
    error (256) 18 19 20 21 22 23 24 27 28 31 37 42 43 44 52 54 57 58 60 61 67 68 69 77 78 79 84 85 88 131
    IF (258) 41 42 43 44
    ELSE (259) 46 47
    REPEAT (260) 126
    UNTIL (261) 126
    WHILE (262) 51 52 54
    FOR (263) 56 57 58
    SWITCH (264) 76 77 78 79
    CASE (265) 83 84 85
    DEFAULT (266) 87 88
    FUNCTION (267) 128
    RETURN (268) 90 91
    CONST (269) 139
    BREAK (270) 16 24
    CONTINUE (271) 15 23
    AND (272) 95
    OR (273) 93
    NOT (274) 115
    EQ (275) 97
    NEQ (276) 98
    GTE (277) 103
    LTE (278) 102
    GT (279) 101
    LT (280) 100
    PLUS (281) 105
    MINUS (282) 106 114
    MUL (283) 108
    DIV (284) 109
    EXP (285) 112
    MOD (286) 110
    ASSIGN (287) 26 28 36 37 64 66 68 69 139
    SEMI (288) 4 5 10 13 14 15 16 59 60 61 126
    COLON (289) 83 87
    COMMA (290) 30 31 132 136
    LPAREN (291) 41 43 44 51 54 56 58 76 78 79 122 126 128 129 130 131
    RPAREN (292) 41 44 51 56 57 76 79 122 126 128 129 130
    LBRACE (293) 17 41 46 51 54 63 76 126 128
    RBRACE (294) 17 41 46 51 54 63 76 126 128
    INT <i> (295) 70 117
    FLOAT <f> (296) 71 118
    CHAR <c> (297) 119
    BOOLEAN <i> (298) 72 120
    IDENTIFIER <s> (299) 26 28 29 30 32 33 34 35 36 37 64 65 66 68 69 73 76 78 79 124 128 129 130 131 138 139
    TYPE <s> (300) 25 26 27 28 64 65 67 68 128 138 139
    STRING <s> (301) 121
    UNKNOWN (302)
    INC (303) 32 34
    DEC (304) 33 35
    UMINUS (305)
    LOWER_THAN_ELSE (306)


Nonterminals, with rules where they appear

    $accept (52)
        on left: 0
    program (53)
        on left: 1
        on right: 0
    statement_list <void_val> (54)
        on left: 2 3
        on right: 1 3 17 41 46 51 54 63 83 87 126 128
    statement (55)
        on left: 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24
        on right: 3
    declaration (56)
        on left: 25 26 27 28
        on right: 4 18
    identifier_list <s> (57)
        on left: 29 30 31
        on right: 25 30 31
    assignment (58)
        on left: 32 33 34 35 36 37
        on right: 5 19 56 57 58
    if_stmt <code_info> (59)
        on left: 41 42 43 44
        on right: 6 47
    @1 (60)
        on left: 38
        on right: 41
    $@2 (61)
        on left: 39
        on right: 41
    $@3 (62)
        on left: 40
        on right: 41
    else_part <code_info> (63)
        on left: 46 47 48
        on right: 41
    $@4 (64)
        on left: 45
        on right: 46
    while_stmt <code_info> (65)
        on left: 51 52 54
        on right: 7
    $@5 (66)
        on left: 49
        on right: 51
    $@6 (67)
        on left: 50
        on right: 51
    $@7 (68)
        on left: 53
        on right: 54
    while_header <code_info> (69)
        on left: 55
        on right: 51 52 54
    for_stmt <code_info> (70)
        on left: 56 57 58
        on right: 8
    for_header <code_info> (71)
        on left: 59 60 61
        on right: 56 57 58
    for_body <code_info> (72)
        on left: 63
        on right: 56 57
    $@8 (73)
        on left: 62
        on right: 63
    for_stmt_declaration (74)
        on left: 64 65 66 67 68 69
        on right: 59 60 61
    CONSTANT_VAL <expr> (75)
        on left: 70 71 72 73
        on right: 83 84
    switch_stmt <code_info> (76)
        on left: 76 77 78 79
        on right: 9
    @9 (77)
        on left: 74
        on right: 76
    $@10 (78)
        on left: 75
        on right: 76
    case_list <void_val> (79)
        on left: 80 81
        on right: 76 81
    case_item (80)
        on left: 83 84 85
        on right: 81
    @11 (81)
        on left: 82
        on right: 83
    default_case <void_val> (82)
        on left: 87 88 89
        on right: 76
    $@12 (83)
        on left: 86
        on right: 87
    return_stmt (84)
        on left: 90 91
        on right: 10 20
    expression <expr> (85)
        on left: 92
        on right: 26 36 41 43 44 51 54 59 60 61 64 66 90 122 126 132 133 139
    logical_expr <expr> (86)
        on left: 93 94
        on right: 92 93
    logical_term <expr> (87)
        on left: 95 96
        on right: 93 94 95
    equality_expr <expr> (88)
        on left: 97 98 99
        on right: 95 96 97 98
    relational_expr <expr> (89)
        on left: 100 101 102 103 104
        on right: 97 98 99 100 101 102 103
    additive_expr <expr> (90)
        on left: 105 106 107
        on right: 100 101 102 103 104 105 106
    multiplicative_expr <expr> (91)
        on left: 108 109 110 111
        on right: 105 106 107 108 109 110
    exponent_expr <expr> (92)
        on left: 112 113
        on right: 108 109 110 111 112
    unary_expr <expr> (93)
        on left: 114 115 116
        on right: 112 113 114 115
    primary_expr <expr> (94)
        on left: 117 118 119 120 121 122 123 124
        on right: 116
    repeat_stmt <code_info> (95)
        on left: 126
        on right: 11
    @13 (96)
        on left: 125
        on right: 126
    function_decl (97)
        on left: 128
        on right: 12
    $@14 (98)
        on left: 127
        on right: 128
    function_call <temp_var> (99)
        on left: 129 130 131
        on right: 14 22 123
    argument_list (100)
        on left: 132 133
        on right: 129 132
    params <param_list> (101)
        on left: 134 135
        on right: 128
    param_list <param_list> (102)
        on left: 136 137
        on right: 135 136
    param <param_list> (103)
        on left: 138
        on right: 136 137
    const_decl (104)
        on left: 139
        on right: 13 21


State 0

    0 $accept: • program $end

    $default  reduce using rule 2 (statement_list)

    program         go to state 1
    statement_list  go to state 2


State 1

    0 $accept: program • $end

    $end  shift, and go to state 3


State 2

    1 program: statement_list •
    3 statement_list: statement_list • statement

    IF          shift, and go to state 4
    REPEAT      shift, and go to state 5
    WHILE       shift, and go to state 6
    FOR         shift, and go to state 7
    SWITCH      shift, and go to state 8
    FUNCTION    shift, and go to state 9
    RETURN      shift, and go to state 10
    CONST       shift, and go to state 11
    BREAK       shift, and go to state 12
    CONTINUE    shift, and go to state 13
    LBRACE      shift, and go to state 14
    IDENTIFIER  shift, and go to state 15
    TYPE        shift, and go to state 16
    INC         shift, and go to state 17
    DEC         shift, and go to state 18

    $default  reduce using rule 1 (program)

    statement      go to state 19
    declaration    go to state 20
    assignment     go to state 21
    if_stmt        go to state 22
    while_stmt     go to state 23
    for_stmt       go to state 24
    switch_stmt    go to state 25
    return_stmt    go to state 26
    repeat_stmt    go to state 27
    function_decl  go to state 28
    function_call  go to state 29
    const_decl     go to state 30


State 3

    0 $accept: program $end •

    $default  accept


State 4

   41 if_stmt: IF • LPAREN expression RPAREN @1 LBRACE $@2 statement_list RBRACE $@3 else_part
   42        | IF • error
   43        | IF • LPAREN expression error
   44        | IF • LPAREN expression RPAREN error

    error   shift, and go to state 31
    LPAREN  shift, and go to state 32


State 5

  126 repeat_stmt: REPEAT • LBRACE @13 statement_list RBRACE UNTIL LPAREN expression RPAREN SEMI

    LBRACE  shift, and go to state 33


State 6

   51 while_stmt: WHILE • while_header LPAREN expression $@5 RPAREN LBRACE $@6 statement_list RBRACE
   52           | WHILE • while_header error
   54           | WHILE • while_header LPAREN expression error LBRACE $@7 statement_list RBRACE

    $default  reduce using rule 55 (while_header)

    while_header  go to state 34


State 7

   56 for_stmt: FOR • LPAREN for_header assignment RPAREN for_body
   57         | FOR • error for_header assignment RPAREN for_body
   58         | FOR • LPAREN for_header assignment error

    error   shift, and go to state 35
    LPAREN  shift, and go to state 36


State 8

   76 switch_stmt: SWITCH • LPAREN IDENTIFIER RPAREN @9 LBRACE $@10 case_list default_case RBRACE
   77            | SWITCH • error
   78            | SWITCH • LPAREN IDENTIFIER error
   79            | SWITCH • LPAREN IDENTIFIER RPAREN error

    error   shift, and go to state 37
    LPAREN  shift, and go to state 38


State 9

  128 function_decl: FUNCTION • TYPE IDENTIFIER LPAREN params RPAREN LBRACE $@14 statement_list RBRACE

    TYPE  shift, and go to state 39


State 10

   90 return_stmt: RETURN • expression
   91            | RETURN •

    NOT         shift, and go to state 40
    MINUS       shift, and go to state 41
    LPAREN      shift, and go to state 42
    INT         shift, and go to state 43
    FLOAT       shift, and go to state 44
    CHAR        shift, and go to state 45
    BOOLEAN     shift, and go to state 46
    IDENTIFIER  shift, and go to state 47
    STRING      shift, and go to state 48

    $default  reduce using rule 91 (return_stmt)

    expression           go to state 49
    logical_expr         go to state 50
    logical_term         go to state 51
    equality_expr        go to state 52
    relational_expr      go to state 53
    additive_expr        go to state 54
    multiplicative_expr  go to state 55
    exponent_expr        go to state 56
    unary_expr           go to state 57
    primary_expr         go to state 58
    function_call        go to state 59


State 11

  139 const_decl: CONST • TYPE IDENTIFIER ASSIGN expression

    TYPE  shift, and go to state 60


State 12

   16 statement: BREAK • SEMI
   24          | BREAK • error

    error  shift, and go to state 61
    SEMI   shift, and go to state 62


State 13

   15 statement: CONTINUE • SEMI
   23          | CONTINUE • error

    error  shift, and go to state 63
    SEMI   shift, and go to state 64


State 14

   17 statement: LBRACE • statement_list RBRACE

    $default  reduce using rule 2 (statement_list)

    statement_list  go to state 65


State 15

   32 assignment: IDENTIFIER • INC
   33           | IDENTIFIER • DEC
   36           | IDENTIFIER • ASSIGN expression
   37           | IDENTIFIER • ASSIGN error
  129 function_call: IDENTIFIER • LPAREN argument_list RPAREN
  130              | IDENTIFIER • LPAREN RPAREN
  131              | IDENTIFIER • LPAREN error

    ASSIGN  shift, and go to state 66
    LPAREN  shift, and go to state 67
    INC     shift, and go to state 68
    DEC     shift, and go to state 69


State 16

   25 declaration: TYPE • identifier_list
   26            | TYPE • IDENTIFIER ASSIGN expression
   27            | TYPE • error
   28            | TYPE • IDENTIFIER ASSIGN error

    error       shift, and go to state 70
    IDENTIFIER  shift, and go to state 71

    identifier_list  go to state 72


State 17

   34 assignment: INC • IDENTIFIER

    IDENTIFIER  shift, and go to state 73


State 18

   35 assignment: DEC • IDENTIFIER

    IDENTIFIER  shift, and go to state 74


State 19

    3 statement_list: statement_list statement •

    $default  reduce using rule 3 (statement_list)


State 20

    4 statement: declaration • SEMI
   18          | declaration • error

    error  shift, and go to state 75
    SEMI   shift, and go to state 76


State 21

    5 statement: assignment • SEMI
   19          | assignment • error

    error  shift, and go to state 77
    SEMI   shift, and go to state 78


State 22

    6 statement: if_stmt •

    $default  reduce using rule 6 (statement)


State 23

    7 statement: while_stmt •

    $default  reduce using rule 7 (statement)


State 24

    8 statement: for_stmt •

    $default  reduce using rule 8 (statement)


State 25

    9 statement: switch_stmt •

    $default  reduce using rule 9 (statement)


State 26

   10 statement: return_stmt • SEMI
   20          | return_stmt • error

    error  shift, and go to state 79
    SEMI   shift, and go to state 80


State 27

   11 statement: repeat_stmt •

    $default  reduce using rule 11 (statement)


State 28

   12 statement: function_decl •

    $default  reduce using rule 12 (statement)


State 29

   14 statement: function_call • SEMI
   22          | function_call • error

    error  shift, and go to state 81
    SEMI   shift, and go to state 82


State 30

   13 statement: const_decl • SEMI
   21          | const_decl • error

    error  shift, and go to state 83
    SEMI   shift, and go to state 84


State 31

   42 if_stmt: IF error •

    $default  reduce using rule 42 (if_stmt)


State 32

   41 if_stmt: IF LPAREN • expression RPAREN @1 LBRACE $@2 statement_list RBRACE $@3 else_part
   43        | IF LPAREN • expression error
   44        | IF LPAREN • expression RPAREN error

    NOT         shift, and go to state 40
    MINUS       shift, and go to state 41
    LPAREN      shift, and go to state 42
    INT         shift, and go to state 43
    FLOAT       shift, and go to state 44
    CHAR        shift, and go to state 45
    BOOLEAN     shift, and go to state 46
    IDENTIFIER  shift, and go to state 47
    STRING      shift, and go to state 48

    expression           go to state 85
    logical_expr         go to state 50
    logical_term         go to state 51
    equality_expr        go to state 52
    relational_expr      go to state 53
    additive_expr        go to state 54
    multiplicative_expr  go to state 55
    exponent_expr        go to state 56
    unary_expr           go to state 57
    primary_expr         go to state 58
    function_call        go to state 59


State 33

  126 repeat_stmt: REPEAT LBRACE • @13 statement_list RBRACE UNTIL LPAREN expression RPAREN SEMI

    $default  reduce using rule 125 (@13)

    @13  go to state 86


State 34

   51 while_stmt: WHILE while_header • LPAREN expression $@5 RPAREN LBRACE $@6 statement_list RBRACE
   52           | WHILE while_header • error
   54           | WHILE while_header • LPAREN expression error LBRACE $@7 statement_list RBRACE

    error   shift, and go to state 87
    LPAREN  shift, and go to state 88


State 35

   57 for_stmt: FOR error • for_header assignment RPAREN for_body

    IDENTIFIER  shift, and go to state 89
    TYPE        shift, and go to state 90

    for_header            go to state 91
    for_stmt_declaration  go to state 92


State 36

   56 for_stmt: FOR LPAREN • for_header assignment RPAREN for_body
   58         | FOR LPAREN • for_header assignment error

    IDENTIFIER  shift, and go to state 89
    TYPE        shift, and go to state 90

    for_header            go to state 93
    for_stmt_declaration  go to state 92


State 37

   77 switch_stmt: SWITCH error •

    $default  reduce using rule 77 (switch_stmt)


State 38

   76 switch_stmt: SWITCH LPAREN • IDENTIFIER RPAREN @9 LBRACE $@10 case_list default_case RBRACE
   78            | SWITCH LPAREN • IDENTIFIER error
   79            | SWITCH LPAREN • IDENTIFIER RPAREN error

    IDENTIFIER  shift, and go to state 94


State 39

  128 function_decl: FUNCTION TYPE • IDENTIFIER LPAREN params RPAREN LBRACE $@14 statement_list RBRACE

    IDENTIFIER  shift, and go to state 95


State 40

  115 unary_expr: NOT • unary_expr

    NOT         shift, and go to state 40
    MINUS       shift, and go to state 41
    LPAREN      shift, and go to state 42
    INT         shift, and go to state 43
    FLOAT       shift, and go to state 44
    CHAR        shift, and go to state 45
    BOOLEAN     shift, and go to state 46
    IDENTIFIER  shift, and go to state 47
    STRING      shift, and go to state 48

    unary_expr     go to state 96
    primary_expr   go to state 58
    function_call  go to state 59


State 41

  114 unary_expr: MINUS • unary_expr

    NOT         shift, and go to state 40
    MINUS       shift, and go to state 41
    LPAREN      shift, and go to state 42
    INT         shift, and go to state 43
    FLOAT       shift, and go to state 44
    CHAR        shift, and go to state 45
    BOOLEAN     shift, and go to state 46
    IDENTIFIER  shift, and go to state 47
    STRING      shift, and go to state 48

    unary_expr     go to state 97
    primary_expr   go to state 58
    function_call  go to state 59


State 42

  122 primary_expr: LPAREN • expression RPAREN

    NOT         shift, and go to state 40
    MINUS       shift, and go to state 41
    LPAREN      shift, and go to state 42
    INT         shift, and go to state 43
    FLOAT       shift, and go to state 44
    CHAR        shift, and go to state 45
    BOOLEAN     shift, and go to state 46
    IDENTIFIER  shift, and go to state 47
    STRING      shift, and go to state 48

    expression           go to state 98
    logical_expr         go to state 50
    logical_term         go to state 51
    equality_expr        go to state 52
    relational_expr      go to state 53
    additive_expr        go to state 54
    multiplicative_expr  go to state 55
    exponent_expr        go to state 56
    unary_expr           go to state 57
    primary_expr         go to state 58
    function_call        go to state 59


State 43

  117 primary_expr: INT •

    $default  reduce using rule 117 (primary_expr)


State 44

  118 primary_expr: FLOAT •

    $default  reduce using rule 118 (primary_expr)


State 45

  119 primary_expr: CHAR •

    $default  reduce using rule 119 (primary_expr)


State 46

  120 primary_expr: BOOLEAN •

    $default  reduce using rule 120 (primary_expr)


State 47

  124 primary_expr: IDENTIFIER •
  129 function_call: IDENTIFIER • LPAREN argument_list RPAREN
  130              | IDENTIFIER • LPAREN RPAREN
  131              | IDENTIFIER • LPAREN error

    LPAREN  shift, and go to state 67

    $default  reduce using rule 124 (primary_expr)


State 48

  121 primary_expr: STRING •

    $default  reduce using rule 121 (primary_expr)


State 49

   90 return_stmt: RETURN expression •

    $default  reduce using rule 90 (return_stmt)


State 50

   92 expression: logical_expr •
   93 logical_expr: logical_expr • OR logical_term

    OR  shift, and go to state 99

    $default  reduce using rule 92 (expression)


State 51

   94 logical_expr: logical_term •
   95 logical_term: logical_term • AND equality_expr

    AND  shift, and go to state 100

    $default  reduce using rule 94 (logical_expr)


State 52

   96 logical_term: equality_expr •
   97 equality_expr: equality_expr • EQ relational_expr
   98              | equality_expr • NEQ relational_expr

    EQ   shift, and go to state 101
    NEQ  shift, and go to state 102

    $default  reduce using rule 96 (logical_term)


State 53

   99 equality_expr: relational_expr •
  100 relational_expr: relational_expr • LT additive_expr
  101                | relational_expr • GT additive_expr
  102                | relational_expr • LTE additive_expr
  103                | relational_expr • GTE additive_expr

    GTE  shift, and go to state 103
    LTE  shift, and go to state 104
    GT   shift, and go to state 105
    LT   shift, and go to state 106

    $default  reduce using rule 99 (equality_expr)


State 54

  104 relational_expr: additive_expr •
  105 additive_expr: additive_expr • PLUS multiplicative_expr
  106              | additive_expr • MINUS multiplicative_expr

    PLUS   shift, and go to state 107
    MINUS  shift, and go to state 108

    $default  reduce using rule 104 (relational_expr)


State 55

  107 additive_expr: multiplicative_expr •
  108 multiplicative_expr: multiplicative_expr • MUL exponent_expr
  109                    | multiplicative_expr • DIV exponent_expr
  110                    | multiplicative_expr • MOD exponent_expr

    MUL  shift, and go to state 109
    DIV  shift, and go to state 110
    MOD  shift, and go to state 111

    $default  reduce using rule 107 (additive_expr)


State 56

  111 multiplicative_expr: exponent_expr •
  112 exponent_expr: exponent_expr • EXP unary_expr

    EXP  shift, and go to state 112

    $default  reduce using rule 111 (multiplicative_expr)


State 57

  113 exponent_expr: unary_expr •

    $default  reduce using rule 113 (exponent_expr)


State 58

  116 unary_expr: primary_expr •

    $default  reduce using rule 116 (unary_expr)


State 59

  123 primary_expr: function_call •

    $default  reduce using rule 123 (primary_expr)


State 60

  139 const_decl: CONST TYPE • IDENTIFIER ASSIGN expression

    IDENTIFIER  shift, and go to state 113


State 61

   24 statement: BREAK error •

    $default  reduce using rule 24 (statement)


State 62

   16 statement: BREAK SEMI •

    $default  reduce using rule 16 (statement)


State 63

   23 statement: CONTINUE error •

    $default  reduce using rule 23 (statement)


State 64

   15 statement: CONTINUE SEMI •

    $default  reduce using rule 15 (statement)


State 65

    3 statement_list: statement_list • statement
   17 statement: LBRACE statement_list • RBRACE

    IF          shift, and go to state 4
    REPEAT      shift, and go to state 5
    WHILE       shift, and go to state 6
    FOR         shift, and go to state 7
    SWITCH      shift, and go to state 8
    FUNCTION    shift, and go to state 9
    RETURN      shift, and go to state 10
    CONST       shift, and go to state 11
    BREAK       shift, and go to state 12
    CONTINUE    shift, and go to state 13
    LBRACE      shift, and go to state 14
    RBRACE      shift, and go to state 114
    IDENTIFIER  shift, and go to state 15
    TYPE        shift, and go to state 16
    INC         shift, and go to state 17
    DEC         shift, and go to state 18

    statement      go to state 19
    declaration    go to state 20
    assignment     go to state 21
    if_stmt        go to state 22
    while_stmt     go to state 23
    for_stmt       go to state 24
    switch_stmt    go to state 25
    return_stmt    go to state 26
    repeat_stmt    go to state 27
    function_decl  go to state 28
    function_call  go to state 29
    const_decl     go to state 30


State 66

   36 assignment: IDENTIFIER ASSIGN • expression
   37           | IDENTIFIER ASSIGN • error

    error       shift, and go to state 115
    NOT         shift, and go to state 40
    MINUS       shift, and go to state 41
    LPAREN      shift, and go to state 42
    INT         shift, and go to state 43
    FLOAT       shift, and go to state 44
    CHAR        shift, and go to state 45
    BOOLEAN     shift, and go to state 46
    IDENTIFIER  shift, and go to state 47
    STRING      shift, and go to state 48

    expression           go to state 116
    logical_expr         go to state 50
    logical_term         go to state 51
    equality_expr        go to state 52
    relational_expr      go to state 53
    additive_expr        go to state 54
    multiplicative_expr  go to state 55
    exponent_expr        go to state 56
    unary_expr           go to state 57
    primary_expr         go to state 58
    function_call        go to state 59


State 67

  129 function_call: IDENTIFIER LPAREN • argument_list RPAREN
  130              | IDENTIFIER LPAREN • RPAREN
  131              | IDENTIFIER LPAREN • error

    error       shift, and go to state 117
    NOT         shift, and go to state 40
    MINUS       shift, and go to state 41
    LPAREN      shift, and go to state 42
    RPAREN      shift, and go to state 118
    INT         shift, and go to state 43
    FLOAT       shift, and go to state 44
    CHAR        shift, and go to state 45
    BOOLEAN     shift, and go to state 46
    IDENTIFIER  shift, and go to state 47
    STRING      shift, and go to state 48

    expression           go to state 119
    logical_expr         go to state 50
    logical_term         go to state 51
    equality_expr        go to state 52
    relational_expr      go to state 53
    additive_expr        go to state 54
    multiplicative_expr  go to state 55
    exponent_expr        go to state 56
    unary_expr           go to state 57
    primary_expr         go to state 58
    function_call        go to state 59
    argument_list        go to state 120


State 68

   32 assignment: IDENTIFIER INC •

    $default  reduce using rule 32 (assignment)


State 69

   33 assignment: IDENTIFIER DEC •

    $default  reduce using rule 33 (assignment)


State 70

   27 declaration: TYPE error •

    $default  reduce using rule 27 (declaration)


State 71

   26 declaration: TYPE IDENTIFIER • ASSIGN expression
   28            | TYPE IDENTIFIER • ASSIGN error
   29 identifier_list: IDENTIFIER •

    ASSIGN  shift, and go to state 121

    $default  reduce using rule 29 (identifier_list)


State 72

   25 declaration: TYPE identifier_list •
   30 identifier_list: identifier_list • COMMA IDENTIFIER
   31                | identifier_list • COMMA error

    COMMA  shift, and go to state 122

    $default  reduce using rule 25 (declaration)


State 73

   34 assignment: INC IDENTIFIER •

    $default  reduce using rule 34 (assignment)


State 74

   35 assignment: DEC IDENTIFIER •

    $default  reduce using rule 35 (assignment)


State 75

   18 statement: declaration error •

    $default  reduce using rule 18 (statement)


State 76

    4 statement: declaration SEMI •

    $default  reduce using rule 4 (statement)


State 77

   19 statement: assignment error •

    $default  reduce using rule 19 (statement)


State 78

    5 statement: assignment SEMI •

    $default  reduce using rule 5 (statement)


State 79

   20 statement: return_stmt error •

    $default  reduce using rule 20 (statement)


State 80

   10 statement: return_stmt SEMI •

    $default  reduce using rule 10 (statement)


State 81

   22 statement: function_call error •

    $default  reduce using rule 22 (statement)


State 82

   14 statement: function_call SEMI •

    $default  reduce using rule 14 (statement)


State 83

   21 statement: const_decl error •

    $default  reduce using rule 21 (statement)


State 84

   13 statement: const_decl SEMI •

    $default  reduce using rule 13 (statement)


State 85

   41 if_stmt: IF LPAREN expression • RPAREN @1 LBRACE $@2 statement_list RBRACE $@3 else_part
   43        | IF LPAREN expression • error
   44        | IF LPAREN expression • RPAREN error

    error   shift, and go to state 123
    RPAREN  shift, and go to state 124


State 86

  126 repeat_stmt: REPEAT LBRACE @13 • statement_list RBRACE UNTIL LPAREN expression RPAREN SEMI

    $default  reduce using rule 2 (statement_list)

    statement_list  go to state 125


State 87

   52 while_stmt: WHILE while_header error •

    $default  reduce using rule 52 (while_stmt)


State 88

   51 while_stmt: WHILE while_header LPAREN • expression $@5 RPAREN LBRACE $@6 statement_list RBRACE
   54           | WHILE while_header LPAREN • expression error LBRACE $@7 statement_list RBRACE

    NOT         shift, and go to state 40
    MINUS       shift, and go to state 41
    LPAREN      shift, and go to state 42
    INT         shift, and go to state 43
    FLOAT       shift, and go to state 44
    CHAR        shift, and go to state 45
    BOOLEAN     shift, and go to state 46
    IDENTIFIER  shift, and go to state 47
    STRING      shift, and go to state 48

    expression           go to state 126
    logical_expr         go to state 50
    logical_term         go to state 51
    equality_expr        go to state 52
    relational_expr      go to state 53
    additive_expr        go to state 54
    multiplicative_expr  go to state 55
    exponent_expr        go to state 56
    unary_expr           go to state 57
    primary_expr         go to state 58
    function_call        go to state 59


State 89

   66 for_stmt_declaration: IDENTIFIER • ASSIGN expression
   69                     | IDENTIFIER • ASSIGN error

    ASSIGN  shift, and go to state 127


State 90

   64 for_stmt_declaration: TYPE • IDENTIFIER ASSIGN expression
   65                     | TYPE • IDENTIFIER
   67                     | TYPE • error
   68                     | TYPE • IDENTIFIER ASSIGN error

    error       shift, and go to state 128
    IDENTIFIER  shift, and go to state 129


State 91

   57 for_stmt: FOR error for_header • assignment RPAREN for_body

    IDENTIFIER  shift, and go to state 130
    INC         shift, and go to state 17
    DEC         shift, and go to state 18

    assignment  go to state 131


State 92

   59 for_header: for_stmt_declaration • SEMI expression SEMI
   60           | for_stmt_declaration • error expression SEMI
   61           | for_stmt_declaration • SEMI expression error

    error  shift, and go to state 132
    SEMI   shift, and go to state 133


State 93

   56 for_stmt: FOR LPAREN for_header • assignment RPAREN for_body
   58         | FOR LPAREN for_header • assignment error

    IDENTIFIER  shift, and go to state 130
    INC         shift, and go to state 17
    DEC         shift, and go to state 18

    assignment  go to state 134


State 94

   76 switch_stmt: SWITCH LPAREN IDENTIFIER • RPAREN @9 LBRACE $@10 case_list default_case RBRACE
   78            | SWITCH LPAREN IDENTIFIER • error
   79            | SWITCH LPAREN IDENTIFIER • RPAREN error

    error   shift, and go to state 135
    RPAREN  shift, and go to state 136


State 95

  128 function_decl: FUNCTION TYPE IDENTIFIER • LPAREN params RPAREN LBRACE $@14 statement_list RBRACE

    LPAREN  shift, and go to state 137


State 96

  115 unary_expr: NOT unary_expr •

    $default  reduce using rule 115 (unary_expr)


State 97

  114 unary_expr: MINUS unary_expr •

    $default  reduce using rule 114 (unary_expr)


State 98

  122 primary_expr: LPAREN expression • RPAREN

    RPAREN  shift, and go to state 138


State 99

   93 logical_expr: logical_expr OR • logical_term

    NOT         shift, and go to state 40
    MINUS       shift, and go to state 41
    LPAREN      shift, and go to state 42
    INT         shift, and go to state 43
    FLOAT       shift, and go to state 44
    CHAR        shift, and go to state 45
    BOOLEAN     shift, and go to state 46
    IDENTIFIER  shift, and go to state 47
    STRING      shift, and go to state 48

    logical_term         go to state 139
    equality_expr        go to state 52
    relational_expr      go to state 53
    additive_expr        go to state 54
    multiplicative_expr  go to state 55
    exponent_expr        go to state 56
    unary_expr           go to state 57
    primary_expr         go to state 58
    function_call        go to state 59


State 100

   95 logical_term: logical_term AND • equality_expr

    NOT         shift, and go to state 40
    MINUS       shift, and go to state 41
    LPAREN      shift, and go to state 42
    INT         shift, and go to state 43
    FLOAT       shift, and go to state 44
    CHAR        shift, and go to state 45
    BOOLEAN     shift, and go to state 46
    IDENTIFIER  shift, and go to state 47
    STRING      shift, and go to state 48

    equality_expr        go to state 140
    relational_expr      go to state 53
    additive_expr        go to state 54
    multiplicative_expr  go to state 55
    exponent_expr        go to state 56
    unary_expr           go to state 57
    primary_expr         go to state 58
    function_call        go to state 59


State 101

   97 equality_expr: equality_expr EQ • relational_expr

    NOT         shift, and go to state 40
    MINUS       shift, and go to state 41
    LPAREN      shift, and go to state 42
    INT         shift, and go to state 43
    FLOAT       shift, and go to state 44
    CHAR        shift, and go to state 45
    BOOLEAN     shift, and go to state 46
    IDENTIFIER  shift, and go to state 47
    STRING      shift, and go to state 48

    relational_expr      go to state 141
    additive_expr        go to state 54
    multiplicative_expr  go to state 55
    exponent_expr        go to state 56
    unary_expr           go to state 57
    primary_expr         go to state 58
    function_call        go to state 59


State 102

   98 equality_expr: equality_expr NEQ • relational_expr

    NOT         shift, and go to state 40
    MINUS       shift, and go to state 41
    LPAREN      shift, and go to state 42
    INT         shift, and go to state 43
    FLOAT       shift, and go to state 44
    CHAR        shift, and go to state 45
    BOOLEAN     shift, and go to state 46
    IDENTIFIER  shift, and go to state 47
    STRING      shift, and go to state 48

    relational_expr      go to state 142
    additive_expr        go to state 54
    multiplicative_expr  go to state 55
    exponent_expr        go to state 56
    unary_expr           go to state 57
    primary_expr         go to state 58
    function_call        go to state 59


State 103

  103 relational_expr: relational_expr GTE • additive_expr

    NOT         shift, and go to state 40
    MINUS       shift, and go to state 41
    LPAREN      shift, and go to state 42
    INT         shift, and go to state 43
    FLOAT       shift, and go to state 44
    CHAR        shift, and go to state 45
    BOOLEAN     shift, and go to state 46
    IDENTIFIER  shift, and go to state 47
    STRING      shift, and go to state 48

    additive_expr        go to state 143
    multiplicative_expr  go to state 55
    exponent_expr        go to state 56
    unary_expr           go to state 57
    primary_expr         go to state 58
    function_call        go to state 59


State 104

  102 relational_expr: relational_expr LTE • additive_expr

    NOT         shift, and go to state 40
    MINUS       shift, and go to state 41
    LPAREN      shift, and go to state 42
    INT         shift, and go to state 43
    FLOAT       shift, and go to state 44
    CHAR        shift, and go to state 45
    BOOLEAN     shift, and go to state 46
    IDENTIFIER  shift, and go to state 47
    STRING      shift, and go to state 48

    additive_expr        go to state 144
    multiplicative_expr  go to state 55
    exponent_expr        go to state 56
    unary_expr           go to state 57
    primary_expr         go to state 58
    function_call        go to state 59


State 105

  101 relational_expr: relational_expr GT • additive_expr

    NOT         shift, and go to state 40
    MINUS       shift, and go to state 41
    LPAREN      shift, and go to state 42
    INT         shift, and go to state 43
    FLOAT       shift, and go to state 44
    CHAR        shift, and go to state 45
    BOOLEAN     shift, and go to state 46
    IDENTIFIER  shift, and go to state 47
    STRING      shift, and go to state 48

    additive_expr        go to state 145
    multiplicative_expr  go to state 55
    exponent_expr        go to state 56
    unary_expr           go to state 57
    primary_expr         go to state 58
    function_call        go to state 59


State 106

  100 relational_expr: relational_expr LT • additive_expr

    NOT         shift, and go to state 40
    MINUS       shift, and go to state 41
    LPAREN      shift, and go to state 42
    INT         shift, and go to state 43
    FLOAT       shift, and go to state 44
    CHAR        shift, and go to state 45
    BOOLEAN     shift, and go to state 46
    IDENTIFIER  shift, and go to state 47
    STRING      shift, and go to state 48

    additive_expr        go to state 146
    multiplicative_expr  go to state 55
    exponent_expr        go to state 56
    unary_expr           go to state 57
    primary_expr         go to state 58
    function_call        go to state 59


State 107

  105 additive_expr: additive_expr PLUS • multiplicative_expr

    NOT         shift, and go to state 40
    MINUS       shift, and go to state 41
    LPAREN      shift, and go to state 42
    INT         shift, and go to state 43
    FLOAT       shift, and go to state 44
    CHAR        shift, and go to state 45
    BOOLEAN     shift, and go to state 46
    IDENTIFIER  shift, and go to state 47
    STRING      shift, and go to state 48

    multiplicative_expr  go to state 147
    exponent_expr        go to state 56
    unary_expr           go to state 57
    primary_expr         go to state 58
    function_call        go to state 59


State 108

  106 additive_expr: additive_expr MINUS • multiplicative_expr

    NOT         shift, and go to state 40
    MINUS       shift, and go to state 41
    LPAREN      shift, and go to state 42
    INT         shift, and go to state 43
    FLOAT       shift, and go to state 44
    CHAR        shift, and go to state 45
    BOOLEAN     shift, and go to state 46
    IDENTIFIER  shift, and go to state 47
    STRING      shift, and go to state 48

    multiplicative_expr  go to state 148
    exponent_expr        go to state 56
    unary_expr           go to state 57
    primary_expr         go to state 58
    function_call        go to state 59


State 109

  108 multiplicative_expr: multiplicative_expr MUL • exponent_expr

    NOT         shift, and go to state 40
    MINUS       shift, and go to state 41
    LPAREN      shift, and go to state 42
    INT         shift, and go to state 43
    FLOAT       shift, and go to state 44
    CHAR        shift, and go to state 45
    BOOLEAN     shift, and go to state 46
    IDENTIFIER  shift, and go to state 47
    STRING      shift, and go to state 48

    exponent_expr  go to state 149
    unary_expr     go to state 57
    primary_expr   go to state 58
    function_call  go to state 59


State 110

  109 multiplicative_expr: multiplicative_expr DIV • exponent_expr

    NOT         shift, and go to state 40
    MINUS       shift, and go to state 41
    LPAREN      shift, and go to state 42
    INT         shift, and go to state 43
    FLOAT       shift, and go to state 44
    CHAR        shift, and go to state 45
    BOOLEAN     shift, and go to state 46
    IDENTIFIER  shift, and go to state 47
    STRING      shift, and go to state 48

    exponent_expr  go to state 150
    unary_expr     go to state 57
    primary_expr   go to state 58
    function_call  go to state 59


State 111

  110 multiplicative_expr: multiplicative_expr MOD • exponent_expr

    NOT         shift, and go to state 40
    MINUS       shift, and go to state 41
    LPAREN      shift, and go to state 42
    INT         shift, and go to state 43
    FLOAT       shift, and go to state 44
    CHAR        shift, and go to state 45
    BOOLEAN     shift, and go to state 46
    IDENTIFIER  shift, and go to state 47
    STRING      shift, and go to state 48

    exponent_expr  go to state 151
    unary_expr     go to state 57
    primary_expr   go to state 58
    function_call  go to state 59


State 112

  112 exponent_expr: exponent_expr EXP • unary_expr

    NOT         shift, and go to state 40
    MINUS       shift, and go to state 41
    LPAREN      shift, and go to state 42
    INT         shift, and go to state 43
    FLOAT       shift, and go to state 44
    CHAR        shift, and go to state 45
    BOOLEAN     shift, and go to state 46
    IDENTIFIER  shift, and go to state 47
    STRING      shift, and go to state 48

    unary_expr     go to state 152
    primary_expr   go to state 58
    function_call  go to state 59


State 113

  139 const_decl: CONST TYPE IDENTIFIER • ASSIGN expression

    ASSIGN  shift, and go to state 153


State 114

   17 statement: LBRACE statement_list RBRACE •

    $default  reduce using rule 17 (statement)


State 115

   37 assignment: IDENTIFIER ASSIGN error •

    $default  reduce using rule 37 (assignment)


State 116

   36 assignment: IDENTIFIER ASSIGN expression •

    $default  reduce using rule 36 (assignment)


State 117

  131 function_call: IDENTIFIER LPAREN error •

    $default  reduce using rule 131 (function_call)


State 118

  130 function_call: IDENTIFIER LPAREN RPAREN •

    $default  reduce using rule 130 (function_call)


State 119

  133 argument_list: expression •

    $default  reduce using rule 133 (argument_list)


State 120

  129 function_call: IDENTIFIER LPAREN argument_list • RPAREN
  132 argument_list: argument_list • COMMA expression

    COMMA   shift, and go to state 154
    RPAREN  shift, and go to state 155


State 121

   26 declaration: TYPE IDENTIFIER ASSIGN • expression
   28            | TYPE IDENTIFIER ASSIGN • error

    error       shift, and go to state 156
    NOT         shift, and go to state 40
    MINUS       shift, and go to state 41
    LPAREN      shift, and go to state 42
    INT         shift, and go to state 43
    FLOAT       shift, and go to state 44
    CHAR        shift, and go to state 45
    BOOLEAN     shift, and go to state 46
    IDENTIFIER  shift, and go to state 47
    STRING      shift, and go to state 48

    expression           go to state 157
    logical_expr         go to state 50
    logical_term         go to state 51
    equality_expr        go to state 52
    relational_expr      go to state 53
    additive_expr        go to state 54
    multiplicative_expr  go to state 55
    exponent_expr        go to state 56
    unary_expr           go to state 57
    primary_expr         go to state 58
    function_call        go to state 59


State 122

   30 identifier_list: identifier_list COMMA • IDENTIFIER
   31                | identifier_list COMMA • error

    error       shift, and go to state 158
    IDENTIFIER  shift, and go to state 159


State 123

   43 if_stmt: IF LPAREN expression error •

    $default  reduce using rule 43 (if_stmt)


State 124

   41 if_stmt: IF LPAREN expression RPAREN • @1 LBRACE $@2 statement_list RBRACE $@3 else_part
   44        | IF LPAREN expression RPAREN • error

    error  shift, and go to state 160

    LBRACE  reduce using rule 38 (@1)

    @1  go to state 161


State 125

    3 statement_list: statement_list • statement
  126 repeat_stmt: REPEAT LBRACE @13 statement_list • RBRACE UNTIL LPAREN expression RPAREN SEMI

    IF          shift, and go to state 4
    REPEAT      shift, and go to state 5
    WHILE       shift, and go to state 6
    FOR         shift, and go to state 7
    SWITCH      shift, and go to state 8
    FUNCTION    shift, and go to state 9
    RETURN      shift, and go to state 10
    CONST       shift, and go to state 11
    BREAK       shift, and go to state 12
    CONTINUE    shift, and go to state 13
    LBRACE      shift, and go to state 14
    RBRACE      shift, and go to state 162
    IDENTIFIER  shift, and go to state 15
    TYPE        shift, and go to state 16
    INC         shift, and go to state 17
    DEC         shift, and go to state 18

    statement      go to state 19
    declaration    go to state 20
    assignment     go to state 21
    if_stmt        go to state 22
    while_stmt     go to state 23
    for_stmt       go to state 24
    switch_stmt    go to state 25
    return_stmt    go to state 26
    repeat_stmt    go to state 27
    function_decl  go to state 28
    function_call  go to state 29
    const_decl     go to state 30


State 126

   51 while_stmt: WHILE while_header LPAREN expression • $@5 RPAREN LBRACE $@6 statement_list RBRACE
   54           | WHILE while_header LPAREN expression • error LBRACE $@7 statement_list RBRACE

    error  shift, and go to state 163

    RPAREN  reduce using rule 49 ($@5)

    $@5  go to state 164


State 127

   66 for_stmt_declaration: IDENTIFIER ASSIGN • expression
   69                     | IDENTIFIER ASSIGN • error

    error       shift, and go to state 165
    NOT         shift, and go to state 40
    MINUS       shift, and go to state 41
    LPAREN      shift, and go to state 42
    INT         shift, and go to state 43
    FLOAT       shift, and go to state 44
    CHAR        shift, and go to state 45
    BOOLEAN     shift, and go to state 46
    IDENTIFIER  shift, and go to state 47
    STRING      shift, and go to state 48

    expression           go to state 166
    logical_expr         go to state 50
    logical_term         go to state 51
    equality_expr        go to state 52
    relational_expr      go to state 53
    additive_expr        go to state 54
    multiplicative_expr  go to state 55
    exponent_expr        go to state 56
    unary_expr           go to state 57
    primary_expr         go to state 58
    function_call        go to state 59


State 128

   67 for_stmt_declaration: TYPE error •

    $default  reduce using rule 67 (for_stmt_declaration)


State 129

   64 for_stmt_declaration: TYPE IDENTIFIER • ASSIGN expression
   65                     | TYPE IDENTIFIER •
   68                     | TYPE IDENTIFIER • ASSIGN error

    ASSIGN  shift, and go to state 167

    $default  reduce using rule 65 (for_stmt_declaration)


State 130

   32 assignment: IDENTIFIER • INC
   33           | IDENTIFIER • DEC
   36           | IDENTIFIER • ASSIGN expression
   37           | IDENTIFIER • ASSIGN error

    ASSIGN  shift, and go to state 66
    INC     shift, and go to state 68
    DEC     shift, and go to state 69


State 131

   57 for_stmt: FOR error for_header assignment • RPAREN for_body

    RPAREN  shift, and go to state 168


State 132

   60 for_header: for_stmt_declaration error • expression SEMI

    NOT         shift, and go to state 40
    MINUS       shift, and go to state 41
    LPAREN      shift, and go to state 42
    INT         shift, and go to state 43
    FLOAT       shift, and go to state 44
    CHAR        shift, and go to state 45
    BOOLEAN     shift, and go to state 46
    IDENTIFIER  shift, and go to state 47
    STRING      shift, and go to state 48

    expression           go to state 169
    logical_expr         go to state 50
    logical_term         go to state 51
    equality_expr        go to state 52
    relational_expr      go to state 53
    additive_expr        go to state 54
    multiplicative_expr  go to state 55
    exponent_expr        go to state 56
    unary_expr           go to state 57
    primary_expr         go to state 58
    function_call        go to state 59


State 133

   59 for_header: for_stmt_declaration SEMI • expression SEMI
   61           | for_stmt_declaration SEMI • expression error

    NOT         shift, and go to state 40
    MINUS       shift, and go to state 41
    LPAREN      shift, and go to state 42
    INT         shift, and go to state 43
    FLOAT       shift, and go to state 44
    CHAR        shift, and go to state 45
    BOOLEAN     shift, and go to state 46
    IDENTIFIER  shift, and go to state 47
    STRING      shift, and go to state 48

    expression           go to state 170
    logical_expr         go to state 50
    logical_term         go to state 51
    equality_expr        go to state 52
    relational_expr      go to state 53
    additive_expr        go to state 54
    multiplicative_expr  go to state 55
    exponent_expr        go to state 56
    unary_expr           go to state 57
    primary_expr         go to state 58
    function_call        go to state 59


State 134

   56 for_stmt: FOR LPAREN for_header assignment • RPAREN for_body
   58         | FOR LPAREN for_header assignment • error

    error   shift, and go to state 171
    RPAREN  shift, and go to state 172


State 135

   78 switch_stmt: SWITCH LPAREN IDENTIFIER error •

    $default  reduce using rule 78 (switch_stmt)


State 136

   76 switch_stmt: SWITCH LPAREN IDENTIFIER RPAREN • @9 LBRACE $@10 case_list default_case RBRACE
   79            | SWITCH LPAREN IDENTIFIER RPAREN • error

    error  shift, and go to state 173

    LBRACE  reduce using rule 74 (@9)

    @9  go to state 174


State 137

  128 function_decl: FUNCTION TYPE IDENTIFIER LPAREN • params RPAREN LBRACE $@14 statement_list RBRACE

    TYPE  shift, and go to state 175

    $default  reduce using rule 134 (params)

    params      go to state 176
    param_list  go to state 177
    param       go to state 178


State 138

  122 primary_expr: LPAREN expression RPAREN •

    $default  reduce using rule 122 (primary_expr)


State 139

   93 logical_expr: logical_expr OR logical_term •
   95 logical_term: logical_term • AND equality_expr

    AND  shift, and go to state 100

    $default  reduce using rule 93 (logical_expr)


State 140

   95 logical_term: logical_term AND equality_expr •
   97 equality_expr: equality_expr • EQ relational_expr
   98              | equality_expr • NEQ relational_expr

    EQ   shift, and go to state 101
    NEQ  shift, and go to state 102

    $default  reduce using rule 95 (logical_term)


State 141

   97 equality_expr: equality_expr EQ relational_expr •
  100 relational_expr: relational_expr • LT additive_expr
  101                | relational_expr • GT additive_expr
  102                | relational_expr • LTE additive_expr
  103                | relational_expr • GTE additive_expr

    GTE  shift, and go to state 103
    LTE  shift, and go to state 104
    GT   shift, and go to state 105
    LT   shift, and go to state 106

    $default  reduce using rule 97 (equality_expr)


State 142

   98 equality_expr: equality_expr NEQ relational_expr •
  100 relational_expr: relational_expr • LT additive_expr
  101                | relational_expr • GT additive_expr
  102                | relational_expr • LTE additive_expr
  103                | relational_expr • GTE additive_expr

    GTE  shift, and go to state 103
    LTE  shift, and go to state 104
    GT   shift, and go to state 105
    LT   shift, and go to state 106

    $default  reduce using rule 98 (equality_expr)


State 143

  103 relational_expr: relational_expr GTE additive_expr •
  105 additive_expr: additive_expr • PLUS multiplicative_expr
  106              | additive_expr • MINUS multiplicative_expr

    PLUS   shift, and go to state 107
    MINUS  shift, and go to state 108

    $default  reduce using rule 103 (relational_expr)


State 144

  102 relational_expr: relational_expr LTE additive_expr •
  105 additive_expr: additive_expr • PLUS multiplicative_expr
  106              | additive_expr • MINUS multiplicative_expr

    PLUS   shift, and go to state 107
    MINUS  shift, and go to state 108

    $default  reduce using rule 102 (relational_expr)


State 145

  101 relational_expr: relational_expr GT additive_expr •
  105 additive_expr: additive_expr • PLUS multiplicative_expr
  106              | additive_expr • MINUS multiplicative_expr

    PLUS   shift, and go to state 107
    MINUS  shift, and go to state 108

    $default  reduce using rule 101 (relational_expr)


State 146

  100 relational_expr: relational_expr LT additive_expr •
  105 additive_expr: additive_expr • PLUS multiplicative_expr
  106              | additive_expr • MINUS multiplicative_expr

    PLUS   shift, and go to state 107
    MINUS  shift, and go to state 108

    $default  reduce using rule 100 (relational_expr)


State 147

  105 additive_expr: additive_expr PLUS multiplicative_expr •
  108 multiplicative_expr: multiplicative_expr • MUL exponent_expr
  109                    | multiplicative_expr • DIV exponent_expr
  110                    | multiplicative_expr • MOD exponent_expr

    MUL  shift, and go to state 109
    DIV  shift, and go to state 110
    MOD  shift, and go to state 111

    $default  reduce using rule 105 (additive_expr)


State 148

  106 additive_expr: additive_expr MINUS multiplicative_expr •
  108 multiplicative_expr: multiplicative_expr • MUL exponent_expr
  109                    | multiplicative_expr • DIV exponent_expr
  110                    | multiplicative_expr • MOD exponent_expr

    MUL  shift, and go to state 109
    DIV  shift, and go to state 110
    MOD  shift, and go to state 111

    $default  reduce using rule 106 (additive_expr)


State 149

  108 multiplicative_expr: multiplicative_expr MUL exponent_expr •
  112 exponent_expr: exponent_expr • EXP unary_expr

    EXP  shift, and go to state 112

    $default  reduce using rule 108 (multiplicative_expr)


State 150

  109 multiplicative_expr: multiplicative_expr DIV exponent_expr •
  112 exponent_expr: exponent_expr • EXP unary_expr

    EXP  shift, and go to state 112

    $default  reduce using rule 109 (multiplicative_expr)


State 151

  110 multiplicative_expr: multiplicative_expr MOD exponent_expr •
  112 exponent_expr: exponent_expr • EXP unary_expr

    EXP  shift, and go to state 112

    $default  reduce using rule 110 (multiplicative_expr)


State 152

  112 exponent_expr: exponent_expr EXP unary_expr •

    $default  reduce using rule 112 (exponent_expr)


State 153

  139 const_decl: CONST TYPE IDENTIFIER ASSIGN • expression

    NOT         shift, and go to state 40
    MINUS       shift, and go to state 41
    LPAREN      shift, and go to state 42
    INT         shift, and go to state 43
    FLOAT       shift, and go to state 44
    CHAR        shift, and go to state 45
    BOOLEAN     shift, and go to state 46
    IDENTIFIER  shift, and go to state 47
    STRING      shift, and go to state 48

    expression           go to state 179
    logical_expr         go to state 50
    logical_term         go to state 51
    equality_expr        go to state 52
    relational_expr      go to state 53
    additive_expr        go to state 54
    multiplicative_expr  go to state 55
    exponent_expr        go to state 56
    unary_expr           go to state 57
    primary_expr         go to state 58
    function_call        go to state 59


State 154

  132 argument_list: argument_list COMMA • expression

    NOT         shift, and go to state 40
    MINUS       shift, and go to state 41
    LPAREN      shift, and go to state 42
    INT         shift, and go to state 43
    FLOAT       shift, and go to state 44
    CHAR        shift, and go to state 45
    BOOLEAN     shift, and go to state 46
    IDENTIFIER  shift, and go to state 47
    STRING      shift, and go to state 48

    expression           go to state 180
    logical_expr         go to state 50
    logical_term         go to state 51
    equality_expr        go to state 52
    relational_expr      go to state 53
    additive_expr        go to state 54
    multiplicative_expr  go to state 55
    exponent_expr        go to state 56
    unary_expr           go to state 57
    primary_expr         go to state 58
    function_call        go to state 59


State 155

  129 function_call: IDENTIFIER LPAREN argument_list RPAREN •

    $default  reduce using rule 129 (function_call)


State 156

   28 declaration: TYPE IDENTIFIER ASSIGN error •

    $default  reduce using rule 28 (declaration)


State 157

   26 declaration: TYPE IDENTIFIER ASSIGN expression •

    $default  reduce using rule 26 (declaration)


State 158

   31 identifier_list: identifier_list COMMA error •

    $default  reduce using rule 31 (identifier_list)


State 159

   30 identifier_list: identifier_list COMMA IDENTIFIER •

    $default  reduce using rule 30 (identifier_list)


State 160

   44 if_stmt: IF LPAREN expression RPAREN error •

    $default  reduce using rule 44 (if_stmt)


State 161

   41 if_stmt: IF LPAREN expression RPAREN @1 • LBRACE $@2 statement_list RBRACE $@3 else_part

    LBRACE  shift, and go to state 181


State 162

  126 repeat_stmt: REPEAT LBRACE @13 statement_list RBRACE • UNTIL LPAREN expression RPAREN SEMI

    UNTIL  shift, and go to state 182


State 163

   54 while_stmt: WHILE while_header LPAREN expression error • LBRACE $@7 statement_list RBRACE

    LBRACE  shift, and go to state 183


State 164

   51 while_stmt: WHILE while_header LPAREN expression $@5 • RPAREN LBRACE $@6 statement_list RBRACE

    RPAREN  shift, and go to state 184


State 165

   69 for_stmt_declaration: IDENTIFIER ASSIGN error •

    $default  reduce using rule 69 (for_stmt_declaration)


State 166

   66 for_stmt_declaration: IDENTIFIER ASSIGN expression •

    $default  reduce using rule 66 (for_stmt_declaration)


State 167

   64 for_stmt_declaration: TYPE IDENTIFIER ASSIGN • expression
   68                     | TYPE IDENTIFIER ASSIGN • error

    error       shift, and go to state 185
    NOT         shift, and go to state 40
    MINUS       shift, and go to state 41
    LPAREN      shift, and go to state 42
    INT         shift, and go to state 43
    FLOAT       shift, and go to state 44
    CHAR        shift, and go to state 45
    BOOLEAN     shift, and go to state 46
    IDENTIFIER  shift, and go to state 47
    STRING      shift, and go to state 48

    expression           go to state 186
    logical_expr         go to state 50
    logical_term         go to state 51
    equality_expr        go to state 52
    relational_expr      go to state 53
    additive_expr        go to state 54
    multiplicative_expr  go to state 55
    exponent_expr        go to state 56
    unary_expr           go to state 57
    primary_expr         go to state 58
    function_call        go to state 59


State 168

   57 for_stmt: FOR error for_header assignment RPAREN • for_body

    LBRACE  shift, and go to state 187

    for_body  go to state 188


State 169

   60 for_header: for_stmt_declaration error expression • SEMI

    SEMI  shift, and go to state 189


State 170

   59 for_header: for_stmt_declaration SEMI expression • SEMI
   61           | for_stmt_declaration SEMI expression • error

    error  shift, and go to state 190
    SEMI   shift, and go to state 191


State 171

   58 for_stmt: FOR LPAREN for_header assignment error •

    $default  reduce using rule 58 (for_stmt)


State 172

   56 for_stmt: FOR LPAREN for_header assignment RPAREN • for_body

    LBRACE  shift, and go to state 187

    for_body  go to state 192


State 173

   79 switch_stmt: SWITCH LPAREN IDENTIFIER RPAREN error •

    $default  reduce using rule 79 (switch_stmt)


State 174

   76 switch_stmt: SWITCH LPAREN IDENTIFIER RPAREN @9 • LBRACE $@10 case_list default_case RBRACE

    LBRACE  shift, and go to state 193


State 175

  138 param: TYPE • IDENTIFIER

    IDENTIFIER  shift, and go to state 194


State 176

  128 function_decl: FUNCTION TYPE IDENTIFIER LPAREN params • RPAREN LBRACE $@14 statement_list RBRACE

    RPAREN  shift, and go to state 195


State 177

  135 params: param_list •
  136 param_list: param_list • COMMA param

    COMMA  shift, and go to state 196

    $default  reduce using rule 135 (params)


State 178

  137 param_list: param •

    $default  reduce using rule 137 (param_list)


State 179

  139 const_decl: CONST TYPE IDENTIFIER ASSIGN expression •

    $default  reduce using rule 139 (const_decl)


State 180

  132 argument_list: argument_list COMMA expression •

    $default  reduce using rule 132 (argument_list)


State 181

   41 if_stmt: IF LPAREN expression RPAREN @1 LBRACE • $@2 statement_list RBRACE $@3 else_part

    $default  reduce using rule 39 ($@2)

    $@2  go to state 197


State 182

  126 repeat_stmt: REPEAT LBRACE @13 statement_list RBRACE UNTIL • LPAREN expression RPAREN SEMI

    LPAREN  shift, and go to state 198


State 183

   54 while_stmt: WHILE while_header LPAREN expression error LBRACE • $@7 statement_list RBRACE

    $default  reduce using rule 53 ($@7)

    $@7  go to state 199


State 184

   51 while_stmt: WHILE while_header LPAREN expression $@5 RPAREN • LBRACE $@6 statement_list RBRACE

    LBRACE  shift, and go to state 200


State 185

   68 for_stmt_declaration: TYPE IDENTIFIER ASSIGN error •

    $default  reduce using rule 68 (for_stmt_declaration)


State 186

   64 for_stmt_declaration: TYPE IDENTIFIER ASSIGN expression •

    $default  reduce using rule 64 (for_stmt_declaration)


State 187

   63 for_body: LBRACE • $@8 statement_list RBRACE

    $default  reduce using rule 62 ($@8)

    $@8  go to state 201


State 188

   57 for_stmt: FOR error for_header assignment RPAREN for_body •

    $default  reduce using rule 57 (for_stmt)


State 189

   60 for_header: for_stmt_declaration error expression SEMI •

    $default  reduce using rule 60 (for_header)


State 190

   61 for_header: for_stmt_declaration SEMI expression error •

    $default  reduce using rule 61 (for_header)


State 191

   59 for_header: for_stmt_declaration SEMI expression SEMI •

    $default  reduce using rule 59 (for_header)


State 192

   56 for_stmt: FOR LPAREN for_header assignment RPAREN for_body •

    $default  reduce using rule 56 (for_stmt)


State 193

   76 switch_stmt: SWITCH LPAREN IDENTIFIER RPAREN @9 LBRACE • $@10 case_list default_case RBRACE

    $default  reduce using rule 75 ($@10)

    $@10  go to state 202


State 194

  138 param: TYPE IDENTIFIER •

    $default  reduce using rule 138 (param)


State 195

  128 function_decl: FUNCTION TYPE IDENTIFIER LPAREN params RPAREN • LBRACE $@14 statement_list RBRACE

    LBRACE  shift, and go to state 203


State 196

  136 param_list: param_list COMMA • param

    TYPE  shift, and go to state 175

    param  go to state 204


State 197

   41 if_stmt: IF LPAREN expression RPAREN @1 LBRACE $@2 • statement_list RBRACE $@3 else_part

    $default  reduce using rule 2 (statement_list)

    statement_list  go to state 205


State 198

  126 repeat_stmt: REPEAT LBRACE @13 statement_list RBRACE UNTIL LPAREN • expression RPAREN SEMI

    NOT         shift, and go to state 40
    MINUS       shift, and go to state 41
    LPAREN      shift, and go to state 42
    INT         shift, and go to state 43
    FLOAT       shift, and go to state 44
    CHAR        shift, and go to state 45
    BOOLEAN     shift, and go to state 46
    IDENTIFIER  shift, and go to state 47
    STRING      shift, and go to state 48

    expression           go to state 206
    logical_expr         go to state 50
    logical_term         go to state 51
    equality_expr        go to state 52
    relational_expr      go to state 53
    additive_expr        go to state 54
    multiplicative_expr  go to state 55
    exponent_expr        go to state 56
    unary_expr           go to state 57
    primary_expr         go to state 58
    function_call        go to state 59


State 199

   54 while_stmt: WHILE while_header LPAREN expression error LBRACE $@7 • statement_list RBRACE

    $default  reduce using rule 2 (statement_list)

    statement_list  go to state 207


State 200

   51 while_stmt: WHILE while_header LPAREN expression $@5 RPAREN LBRACE • $@6 statement_list RBRACE

    $default  reduce using rule 50 ($@6)

    $@6  go to state 208


State 201

   63 for_body: LBRACE $@8 • statement_list RBRACE

    $default  reduce using rule 2 (statement_list)

    statement_list  go to state 209


State 202

   76 switch_stmt: SWITCH LPAREN IDENTIFIER RPAREN @9 LBRACE $@10 • case_list default_case RBRACE

    $default  reduce using rule 80 (case_list)

    case_list  go to state 210


State 203

  128 function_decl: FUNCTION TYPE IDENTIFIER LPAREN params RPAREN LBRACE • $@14 statement_list RBRACE

    $default  reduce using rule 127 ($@14)

    $@14  go to state 211


State 204

  136 param_list: param_list COMMA param •

    $default  reduce using rule 136 (param_list)


State 205

    3 statement_list: statement_list • statement
   41 if_stmt: IF LPAREN expression RPAREN @1 LBRACE $@2 statement_list • RBRACE $@3 else_part

    IF          shift, and go to state 4
    REPEAT      shift, and go to state 5
    WHILE       shift, and go to state 6
    FOR         shift, and go to state 7
    SWITCH      shift, and go to state 8
    FUNCTION    shift, and go to state 9
    RETURN      shift, and go to state 10
    CONST       shift, and go to state 11
    BREAK       shift, and go to state 12
    CONTINUE    shift, and go to state 13
    LBRACE      shift, and go to state 14
    RBRACE      shift, and go to state 212
    IDENTIFIER  shift, and go to state 15
    TYPE        shift, and go to state 16
    INC         shift, and go to state 17
    DEC         shift, and go to state 18

    statement      go to state 19
    declaration    go to state 20
    assignment     go to state 21
    if_stmt        go to state 22
    while_stmt     go to state 23
    for_stmt       go to state 24
    switch_stmt    go to state 25
    return_stmt    go to state 26
    repeat_stmt    go to state 27
    function_decl  go to state 28
    function_call  go to state 29
    const_decl     go to state 30


State 206

  126 repeat_stmt: REPEAT LBRACE @13 statement_list RBRACE UNTIL LPAREN expression • RPAREN SEMI

    RPAREN  shift, and go to state 213


State 207

    3 statement_list: statement_list • statement
   54 while_stmt: WHILE while_header LPAREN expression error LBRACE $@7 statement_list • RBRACE

    IF          shift, and go to state 4
    REPEAT      shift, and go to state 5
    WHILE       shift, and go to state 6
    FOR         shift, and go to state 7
    SWITCH      shift, and go to state 8
    FUNCTION    shift, and go to state 9
    RETURN      shift, and go to state 10
    CONST       shift, and go to state 11
    BREAK       shift, and go to state 12
    CONTINUE    shift, and go to state 13
    LBRACE      shift, and go to state 14
    RBRACE      shift, and go to state 214
    IDENTIFIER  shift, and go to state 15
    TYPE        shift, and go to state 16
    INC         shift, and go to state 17
    DEC         shift, and go to state 18

    statement      go to state 19
    declaration    go to state 20
    assignment     go to state 21
    if_stmt        go to state 22
    while_stmt     go to state 23
    for_stmt       go to state 24
    switch_stmt    go to state 25
    return_stmt    go to state 26
    repeat_stmt    go to state 27
    function_decl  go to state 28
    function_call  go to state 29
    const_decl     go to state 30


State 208

   51 while_stmt: WHILE while_header LPAREN expression $@5 RPAREN LBRACE $@6 • statement_list RBRACE

    $default  reduce using rule 2 (statement_list)

    statement_list  go to state 215


State 209

    3 statement_list: statement_list • statement
   63 for_body: LBRACE $@8 statement_list • RBRACE

    IF          shift, and go to state 4
    REPEAT      shift, and go to state 5
    WHILE       shift, and go to state 6
    FOR         shift, and go to state 7
    SWITCH      shift, and go to state 8
    FUNCTION    shift, and go to state 9
    RETURN      shift, and go to state 10
    CONST       shift, and go to state 11
    BREAK       shift, and go to state 12
    CONTINUE    shift, and go to state 13
    LBRACE      shift, and go to state 14
    RBRACE      shift, and go to state 216
    IDENTIFIER  shift, and go to state 15
    TYPE        shift, and go to state 16
    INC         shift, and go to state 17
    DEC         shift, and go to state 18

    statement      go to state 19
    declaration    go to state 20
    assignment     go to state 21
    if_stmt        go to state 22
    while_stmt     go to state 23
    for_stmt       go to state 24
    switch_stmt    go to state 25
    return_stmt    go to state 26
    repeat_stmt    go to state 27
    function_decl  go to state 28
    function_call  go to state 29
    const_decl     go to state 30


State 210

   76 switch_stmt: SWITCH LPAREN IDENTIFIER RPAREN @9 LBRACE $@10 case_list • default_case RBRACE
   81 case_list: case_list • case_item

    CASE     shift, and go to state 217
    DEFAULT  shift, and go to state 218

    $default  reduce using rule 89 (default_case)

    case_item     go to state 219
    default_case  go to state 220


State 211

  128 function_decl: FUNCTION TYPE IDENTIFIER LPAREN params RPAREN LBRACE $@14 • statement_list RBRACE

    $default  reduce using rule 2 (statement_list)

    statement_list  go to state 221


State 212

   41 if_stmt: IF LPAREN expression RPAREN @1 LBRACE $@2 statement_list RBRACE • $@3 else_part

    $default  reduce using rule 40 ($@3)

    $@3  go to state 222


State 213

  126 repeat_stmt: REPEAT LBRACE @13 statement_list RBRACE UNTIL LPAREN expression RPAREN • SEMI

    SEMI  shift, and go to state 223


State 214

   54 while_stmt: WHILE while_header LPAREN expression error LBRACE $@7 statement_list RBRACE •

    $default  reduce using rule 54 (while_stmt)


State 215

    3 statement_list: statement_list • statement
   51 while_stmt: WHILE while_header LPAREN expression $@5 RPAREN LBRACE $@6 statement_list • RBRACE

    IF          shift, and go to state 4
    REPEAT      shift, and go to state 5
    WHILE       shift, and go to state 6
    FOR         shift, and go to state 7
    SWITCH      shift, and go to state 8
    FUNCTION    shift, and go to state 9
    RETURN      shift, and go to state 10
    CONST       shift, and go to state 11
    BREAK       shift, and go to state 12
    CONTINUE    shift, and go to state 13
    LBRACE      shift, and go to state 14
    RBRACE      shift, and go to state 224
    IDENTIFIER  shift, and go to state 15
    TYPE        shift, and go to state 16
    INC         shift, and go to state 17
    DEC         shift, and go to state 18

    statement      go to state 19
    declaration    go to state 20
    assignment     go to state 21
    if_stmt        go to state 22
    while_stmt     go to state 23
    for_stmt       go to state 24
    switch_stmt    go to state 25
    return_stmt    go to state 26
    repeat_stmt    go to state 27
    function_decl  go to state 28
    function_call  go to state 29
    const_decl     go to state 30


State 216

   63 for_body: LBRACE $@8 statement_list RBRACE •

    $default  reduce using rule 63 (for_body)


State 217

   83 case_item: CASE • CONSTANT_VAL COLON @11 statement_list
   84          | CASE • CONSTANT_VAL error
   85          | CASE • error

    error       shift, and go to state 225
    INT         shift, and go to state 226
    FLOAT       shift, and go to state 227
    BOOLEAN     shift, and go to state 228
    IDENTIFIER  shift, and go to state 229

    CONSTANT_VAL  go to state 230


State 218

   87 default_case: DEFAULT • COLON $@12 statement_list
   88             | DEFAULT • error

    error  shift, and go to state 231
    COLON  shift, and go to state 232


State 219

   81 case_list: case_list case_item •

    $default  reduce using rule 81 (case_list)


State 220

   76 switch_stmt: SWITCH LPAREN IDENTIFIER RPAREN @9 LBRACE $@10 case_list default_case • RBRACE

    RBRACE  shift, and go to state 233


State 221

    3 statement_list: statement_list • statement
  128 function_decl: FUNCTION TYPE IDENTIFIER LPAREN params RPAREN LBRACE $@14 statement_list • RBRACE

    IF          shift, and go to state 4
    REPEAT      shift, and go to state 5
    WHILE       shift, and go to state 6
    FOR         shift, and go to state 7
    SWITCH      shift, and go to state 8
    FUNCTION    shift, and go to state 9
    RETURN      shift, and go to state 10
    CONST       shift, and go to state 11
    BREAK       shift, and go to state 12
    CONTINUE    shift, and go to state 13
    LBRACE      shift, and go to state 14
    RBRACE      shift, and go to state 234
    IDENTIFIER  shift, and go to state 15
    TYPE        shift, and go to state 16
    INC         shift, and go to state 17
    DEC         shift, and go to state 18

    statement      go to state 19
    declaration    go to state 20
    assignment     go to state 21
    if_stmt        go to state 22
    while_stmt     go to state 23
    for_stmt       go to state 24
    switch_stmt    go to state 25
    return_stmt    go to state 26
    repeat_stmt    go to state 27
    function_decl  go to state 28
    function_call  go to state 29
    const_decl     go to state 30


State 222

   41 if_stmt: IF LPAREN expression RPAREN @1 LBRACE $@2 statement_list RBRACE $@3 • else_part

    ELSE  shift, and go to state 235

    $default  reduce using rule 48 (else_part)

    else_part  go to state 236


State 223

  126 repeat_stmt: REPEAT LBRACE @13 statement_list RBRACE UNTIL LPAREN expression RPAREN SEMI •

    $default  reduce using rule 126 (repeat_stmt)


State 224

   51 while_stmt: WHILE while_header LPAREN expression $@5 RPAREN LBRACE $@6 statement_list RBRACE •

    $default  reduce using rule 51 (while_stmt)


State 225

   85 case_item: CASE error •

    $default  reduce using rule 85 (case_item)


State 226

   70 CONSTANT_VAL: INT •

    $default  reduce using rule 70 (CONSTANT_VAL)


State 227

   71 CONSTANT_VAL: FLOAT •

    $default  reduce using rule 71 (CONSTANT_VAL)


State 228

   72 CONSTANT_VAL: BOOLEAN •

    $default  reduce using rule 72 (CONSTANT_VAL)


State 229

   73 CONSTANT_VAL: IDENTIFIER •

    $default  reduce using rule 73 (CONSTANT_VAL)


State 230

   83 case_item: CASE CONSTANT_VAL • COLON @11 statement_list
   84          | CASE CONSTANT_VAL • error

    error  shift, and go to state 237
    COLON  shift, and go to state 238


State 231

   88 default_case: DEFAULT error •

    $default  reduce using rule 88 (default_case)


State 232

   87 default_case: DEFAULT COLON • $@12 statement_list

    $default  reduce using rule 86 ($@12)

    $@12  go to state 239


State 233

   76 switch_stmt: SWITCH LPAREN IDENTIFIER RPAREN @9 LBRACE $@10 case_list default_case RBRACE •

    $default  reduce using rule 76 (switch_stmt)


State 234

  128 function_decl: FUNCTION TYPE IDENTIFIER LPAREN params RPAREN LBRACE $@14 statement_list RBRACE •

    $default  reduce using rule 128 (function_decl)


State 235

   46 else_part: ELSE • LBRACE $@4 statement_list RBRACE
   47          | ELSE • if_stmt

    IF      shift, and go to state 4
    LBRACE  shift, and go to state 240

    if_stmt  go to state 241


State 236

   41 if_stmt: IF LPAREN expression RPAREN @1 LBRACE $@2 statement_list RBRACE $@3 else_part •

    $default  reduce using rule 41 (if_stmt)


State 237

   84 case_item: CASE CONSTANT_VAL error •

    $default  reduce using rule 84 (case_item)


State 238

   83 case_item: CASE CONSTANT_VAL COLON • @11 statement_list

    $default  reduce using rule 82 (@11)

    @11  go to state 242


State 239

   87 default_case: DEFAULT COLON $@12 • statement_list

    $default  reduce using rule 2 (statement_list)

    statement_list  go to state 243


State 240

   46 else_part: ELSE LBRACE • $@4 statement_list RBRACE

    $default  reduce using rule 45 ($@4)

    $@4  go to state 244


State 241

   47 else_part: ELSE if_stmt •

    $default  reduce using rule 47 (else_part)


State 242

   83 case_item: CASE CONSTANT_VAL COLON @11 • statement_list

    $default  reduce using rule 2 (statement_list)

    statement_list  go to state 245


State 243

    3 statement_list: statement_list • statement
   87 default_case: DEFAULT COLON $@12 statement_list •

    IF          shift, and go to state 4
    REPEAT      shift, and go to state 5
    WHILE       shift, and go to state 6
    FOR         shift, and go to state 7
    SWITCH      shift, and go to state 8
    FUNCTION    shift, and go to state 9
    RETURN      shift, and go to state 10
    CONST       shift, and go to state 11
    BREAK       shift, and go to state 12
    CONTINUE    shift, and go to state 13
    LBRACE      shift, and go to state 14
    IDENTIFIER  shift, and go to state 15
    TYPE        shift, and go to state 16
    INC         shift, and go to state 17
    DEC         shift, and go to state 18

    $default  reduce using rule 87 (default_case)

    statement      go to state 19
    declaration    go to state 20
    assignment     go to state 21
    if_stmt        go to state 22
    while_stmt     go to state 23
    for_stmt       go to state 24
    switch_stmt    go to state 25
    return_stmt    go to state 26
    repeat_stmt    go to state 27
    function_decl  go to state 28
    function_call  go to state 29
    const_decl     go to state 30


State 244

   46 else_part: ELSE LBRACE $@4 • statement_list RBRACE

    $default  reduce using rule 2 (statement_list)

    statement_list  go to state 246


State 245

    3 statement_list: statement_list • statement
   83 case_item: CASE CONSTANT_VAL COLON @11 statement_list •

    IF          shift, and go to state 4
    REPEAT      shift, and go to state 5
    WHILE       shift, and go to state 6
    FOR         shift, and go to state 7
    SWITCH      shift, and go to state 8
    FUNCTION    shift, and go to state 9
    RETURN      shift, and go to state 10
    CONST       shift, and go to state 11
    BREAK       shift, and go to state 12
    CONTINUE    shift, and go to state 13
    LBRACE      shift, and go to state 14
    IDENTIFIER  shift, and go to state 15
    TYPE        shift, and go to state 16
    INC         shift, and go to state 17
    DEC         shift, and go to state 18

    $default  reduce using rule 83 (case_item)

    statement      go to state 19
    declaration    go to state 20
    assignment     go to state 21
    if_stmt        go to state 22
    while_stmt     go to state 23
    for_stmt       go to state 24
    switch_stmt    go to state 25
    return_stmt    go to state 26
    repeat_stmt    go to state 27
    function_decl  go to state 28
    function_call  go to state 29
    const_decl     go to state 30


State 246

    3 statement_list: statement_list • statement
   46 else_part: ELSE LBRACE $@4 statement_list • RBRACE

    IF          shift, and go to state 4
    REPEAT      shift, and go to state 5
    WHILE       shift, and go to state 6
    FOR         shift, and go to state 7
    SWITCH      shift, and go to state 8
    FUNCTION    shift, and go to state 9
    RETURN      shift, and go to state 10
    CONST       shift, and go to state 11
    BREAK       shift, and go to state 12
    CONTINUE    shift, and go to state 13
    LBRACE      shift, and go to state 14
    RBRACE      shift, and go to state 247
    IDENTIFIER  shift, and go to state 15
    TYPE        shift, and go to state 16
    INC         shift, and go to state 17
    DEC         shift, and go to state 18

    statement      go to state 19
    declaration    go to state 20
    assignment     go to state 21
    if_stmt        go to state 22
    while_stmt     go to state 23
    for_stmt       go to state 24
    switch_stmt    go to state 25
    return_stmt    go to state 26
    repeat_stmt    go to state 27
    function_decl  go to state 28
    function_call  go to state 29
    const_decl     go to state 30


State 247

   46 else_part: ELSE LBRACE $@4 statement_list RBRACE •

    $default  reduce using rule 46 (else_part)
