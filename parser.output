Terminals unused in grammar

    UNKNOWN
    UMINUS
    LOWER_THAN_ELSE


Grammar

    0 $accept: program $end

    1 program: statement_list

    2 statement_list: ε
    3               | statement_list statement

    4 statement: declaration SEMI
    5          | assignment SEMI
    6          | if_stmt
    7          | while_stmt
    8          | for_stmt
    9          | switch_stmt
   10          | return_stmt SEMI
   11          | repeat_stmt
   12          | function_decl
   13          | const_decl SEMI
   14          | function_call SEMI
   15          | CONTINUE SEMI
   16          | BREAK SEMI
   17          | LBRACE statement_list RBRACE
   18          | declaration error
   19          | assignment error
   20          | return_stmt error
   21          | const_decl error
   22          | function_call error
   23          | CONTINUE error
   24          | BREAK error

   25 declaration: TYPE identifier_list
   26            | TYPE IDENTIFIER ASSIGN expression
   27            | TYPE error
   28            | TYPE IDENTIFIER ASSIGN error

   29 identifier_list: IDENTIFIER
   30                | identifier_list COMMA IDENTIFIER
   31                | identifier_list COMMA error

   32 assignment: IDENTIFIER INC
   33           | IDENTIFIER DEC
   34           | INC IDENTIFIER
   35           | DEC IDENTIFIER
   36           | IDENTIFIER ASSIGN expression
   37           | IDENTIFIER ASSIGN error

   38 @1: ε

   39 $@2: ε

   40 $@3: ε

   41 if_stmt: IF LPAREN expression RPAREN @1 LBRACE $@2 statement_list RBRACE $@3 else_part
   42        | IF error
   43        | IF LPAREN expression error
   44        | IF LPAREN expression RPAREN error

   45 $@4: ε

   46 else_part: ELSE LBRACE $@4 statement_list RBRACE
   47          | ELSE if_stmt
   48          | ε

   49 @5: ε

   50 @6: ε

   51 $@7: ε

   52 while_stmt: WHILE @5 LPAREN expression RPAREN @6 LBRACE $@7 statement_list RBRACE

   53 for_stmt: FOR LPAREN for_header SEMI expression SEMI assignment RPAREN for_body
   54         | FOR error
   55         | FOR LPAREN for_header SEMI expression SEMI assignment error

   56 for_header: for_stmt_declaration
   57           | for_stmt_declaration error

   58 $@8: ε

   59 for_body: LBRACE $@8 statement_list RBRACE

   60 for_stmt_declaration: TYPE IDENTIFIER ASSIGN expression
   61                     | TYPE IDENTIFIER
   62                     | IDENTIFIER ASSIGN expression
   63                     | TYPE error
   64                     | TYPE IDENTIFIER ASSIGN error
   65                     | IDENTIFIER ASSIGN error

   66 CONSTANT_VAL: INT
   67             | FLOAT
   68             | BOOLEAN
   69             | IDENTIFIER

   70 @9: ε

   71 $@10: ε

   72 switch_stmt: SWITCH LPAREN IDENTIFIER RPAREN @9 LBRACE $@10 case_list default_case RBRACE
   73            | SWITCH error
   74            | SWITCH LPAREN IDENTIFIER error
   75            | SWITCH LPAREN IDENTIFIER RPAREN error

   76 case_list: ε
   77          | case_list case_item

   78 @11: ε

   79 case_item: CASE CONSTANT_VAL COLON @11 statement_list
   80          | CASE CONSTANT_VAL error
   81          | CASE error

   82 $@12: ε

   83 default_case: DEFAULT COLON $@12 statement_list
   84             | DEFAULT error
   85             | ε

   86 return_stmt: RETURN expression
   87            | RETURN

   88 expression: logical_expr

   89 logical_expr: logical_expr OR logical_term
   90             | logical_term

   91 logical_term: logical_term AND equality_expr
   92             | equality_expr

   93 equality_expr: equality_expr EQ relational_expr
   94              | equality_expr NEQ relational_expr
   95              | relational_expr

   96 relational_expr: relational_expr LT additive_expr
   97                | relational_expr GT additive_expr
   98                | relational_expr LTE additive_expr
   99                | relational_expr GTE additive_expr
  100                | additive_expr

  101 additive_expr: additive_expr PLUS multiplicative_expr
  102              | additive_expr MINUS multiplicative_expr
  103              | multiplicative_expr

  104 multiplicative_expr: multiplicative_expr MUL exponent_expr
  105                    | multiplicative_expr DIV exponent_expr
  106                    | multiplicative_expr MOD exponent_expr
  107                    | exponent_expr

  108 exponent_expr: exponent_expr EXP unary_expr
  109              | unary_expr

  110 unary_expr: MINUS unary_expr
  111           | NOT unary_expr
  112           | primary_expr

  113 primary_expr: INT
  114             | FLOAT
  115             | CHAR
  116             | BOOLEAN
  117             | STRING
  118             | LPAREN expression RPAREN
  119             | function_call
  120             | IDENTIFIER

  121 @13: ε

  122 repeat_stmt: REPEAT LBRACE @13 statement_list RBRACE UNTIL LPAREN expression RPAREN SEMI

  123 $@14: ε

  124 function_decl: FUNCTION TYPE IDENTIFIER LPAREN params RPAREN LBRACE $@14 statement_list RBRACE

  125 function_call: IDENTIFIER LPAREN argument_list RPAREN
  126              | IDENTIFIER LPAREN RPAREN
  127              | IDENTIFIER LPAREN error

  128 argument_list: argument_list COMMA expression
  129              | expression

  130 params: ε
  131       | param_list

  132 param_list: param_list COMMA param
  133           | param

  134 param: TYPE IDENTIFIER

  135 const_decl: CONST TYPE IDENTIFIER ASSIGN expression


Terminals, with rules where they appear

    $end (0) 0
    error (256) 18 19 20 21 22 23 24 27 28 31 37 42 43 44 54 55 57 63 64 65 73 74 75 80 81 84 127
    IF (258) 41 42 43 44
    ELSE (259) 46 47
    REPEAT (260) 122
    UNTIL (261) 122
    WHILE (262) 52
    FOR (263) 53 54 55
    SWITCH (264) 72 73 74 75
    CASE (265) 79 80 81
    DEFAULT (266) 83 84
    FUNCTION (267) 124
    RETURN (268) 86 87
    CONST (269) 135
    BREAK (270) 16 24
    CONTINUE (271) 15 23
    AND (272) 91
    OR (273) 89
    NOT (274) 111
    EQ (275) 93
    NEQ (276) 94
    GTE (277) 99
    LTE (278) 98
    GT (279) 97
    LT (280) 96
    PLUS (281) 101
    MINUS (282) 102 110
    MUL (283) 104
    DIV (284) 105
    EXP (285) 108
    MOD (286) 106
    ASSIGN (287) 26 28 36 37 60 62 64 65 135
    SEMI (288) 4 5 10 13 14 15 16 53 55 122
    COLON (289) 79 83
    COMMA (290) 30 31 128 132
    LPAREN (291) 41 43 44 52 53 55 72 74 75 118 122 124 125 126 127
    RPAREN (292) 41 44 52 53 72 75 118 122 124 125 126
    LBRACE (293) 17 41 46 52 59 72 122 124
    RBRACE (294) 17 41 46 52 59 72 122 124
    INT <i> (295) 66 113
    FLOAT <f> (296) 67 114
    CHAR <c> (297) 115
    BOOLEAN <i> (298) 68 116
    IDENTIFIER <s> (299) 26 28 29 30 32 33 34 35 36 37 60 61 62 64 65 69 72 74 75 120 124 125 126 127 134 135
    TYPE <s> (300) 25 26 27 28 60 61 63 64 124 134 135
    STRING <s> (301) 117
    UNKNOWN (302)
    INC (303) 32 34
    DEC (304) 33 35
    UMINUS (305)
    LOWER_THAN_ELSE (306)


Nonterminals, with rules where they appear

    $accept (52)
        on left: 0
    program (53)
        on left: 1
        on right: 0
    statement_list <void_val> (54)
        on left: 2 3
        on right: 1 3 17 41 46 52 59 79 83 122 124
    statement (55)
        on left: 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24
        on right: 3
    declaration (56)
        on left: 25 26 27 28
        on right: 4 18
    identifier_list <s> (57)
        on left: 29 30 31
        on right: 25 30 31
    assignment (58)
        on left: 32 33 34 35 36 37
        on right: 5 19 53 55
    if_stmt <code_info> (59)
        on left: 41 42 43 44
        on right: 6 47
    @1 (60)
        on left: 38
        on right: 41
    $@2 (61)
        on left: 39
        on right: 41
    $@3 (62)
        on left: 40
        on right: 41
    else_part <code_info> (63)
        on left: 46 47 48
        on right: 41
    $@4 (64)
        on left: 45
        on right: 46
    while_stmt <code_info> (65)
        on left: 52
        on right: 7
    @5 (66)
        on left: 49
        on right: 52
    @6 (67)
        on left: 50
        on right: 52
    $@7 (68)
        on left: 51
        on right: 52
    for_stmt <code_info> (69)
        on left: 53 54 55
        on right: 8
    for_header <code_info> (70)
        on left: 56 57
        on right: 53 55
    for_body <code_info> (71)
        on left: 59
        on right: 53
    $@8 (72)
        on left: 58
        on right: 59
    for_stmt_declaration (73)
        on left: 60 61 62 63 64 65
        on right: 56 57
    CONSTANT_VAL <expr> (74)
        on left: 66 67 68 69
        on right: 79 80
    switch_stmt <code_info> (75)
        on left: 72 73 74 75
        on right: 9
    @9 (76)
        on left: 70
        on right: 72
    $@10 (77)
        on left: 71
        on right: 72
    case_list <void_val> (78)
        on left: 76 77
        on right: 72 77
    case_item (79)
        on left: 79 80 81
        on right: 77
    @11 (80)
        on left: 78
        on right: 79
    default_case <void_val> (81)
        on left: 83 84 85
        on right: 72
    $@12 (82)
        on left: 82
        on right: 83
    return_stmt (83)
        on left: 86 87
        on right: 10 20
    expression <expr> (84)
        on left: 88
        on right: 26 36 41 43 44 52 53 55 60 62 86 118 122 128 129 135
    logical_expr <expr> (85)
        on left: 89 90
        on right: 88 89
    logical_term <expr> (86)
        on left: 91 92
        on right: 89 90 91
    equality_expr <expr> (87)
        on left: 93 94 95
        on right: 91 92 93 94
    relational_expr <expr> (88)
        on left: 96 97 98 99 100
        on right: 93 94 95 96 97 98 99
    additive_expr <expr> (89)
        on left: 101 102 103
        on right: 96 97 98 99 100 101 102
    multiplicative_expr <expr> (90)
        on left: 104 105 106 107
        on right: 101 102 103 104 105 106
    exponent_expr <expr> (91)
        on left: 108 109
        on right: 104 105 106 107 108
    unary_expr <expr> (92)
        on left: 110 111 112
        on right: 108 109 110 111
    primary_expr <expr> (93)
        on left: 113 114 115 116 117 118 119 120
        on right: 112
    repeat_stmt <code_info> (94)
        on left: 122
        on right: 11
    @13 (95)
        on left: 121
        on right: 122
    function_decl (96)
        on left: 124
        on right: 12
    $@14 (97)
        on left: 123
        on right: 124
    function_call <temp_var> (98)
        on left: 125 126 127
        on right: 14 22 119
    argument_list (99)
        on left: 128 129
        on right: 125 128
    params <param_list> (100)
        on left: 130 131
        on right: 124
    param_list <param_list> (101)
        on left: 132 133
        on right: 131 132
    param <param_list> (102)
        on left: 134
        on right: 132 133
    const_decl (103)
        on left: 135
        on right: 13 21


State 0

    0 $accept: • program $end

    $default  reduce using rule 2 (statement_list)

    program         go to state 1
    statement_list  go to state 2


State 1

    0 $accept: program • $end

    $end  shift, and go to state 3


State 2

    1 program: statement_list •
    3 statement_list: statement_list • statement

    IF          shift, and go to state 4
    REPEAT      shift, and go to state 5
    WHILE       shift, and go to state 6
    FOR         shift, and go to state 7
    SWITCH      shift, and go to state 8
    FUNCTION    shift, and go to state 9
    RETURN      shift, and go to state 10
    CONST       shift, and go to state 11
    BREAK       shift, and go to state 12
    CONTINUE    shift, and go to state 13
    LBRACE      shift, and go to state 14
    IDENTIFIER  shift, and go to state 15
    TYPE        shift, and go to state 16
    INC         shift, and go to state 17
    DEC         shift, and go to state 18

    $default  reduce using rule 1 (program)

    statement      go to state 19
    declaration    go to state 20
    assignment     go to state 21
    if_stmt        go to state 22
    while_stmt     go to state 23
    for_stmt       go to state 24
    switch_stmt    go to state 25
    return_stmt    go to state 26
    repeat_stmt    go to state 27
    function_decl  go to state 28
    function_call  go to state 29
    const_decl     go to state 30


State 3

    0 $accept: program $end •

    $default  accept


State 4

   41 if_stmt: IF • LPAREN expression RPAREN @1 LBRACE $@2 statement_list RBRACE $@3 else_part
   42        | IF • error
   43        | IF • LPAREN expression error
   44        | IF • LPAREN expression RPAREN error

    error   shift, and go to state 31
    LPAREN  shift, and go to state 32


State 5

  122 repeat_stmt: REPEAT • LBRACE @13 statement_list RBRACE UNTIL LPAREN expression RPAREN SEMI

    LBRACE  shift, and go to state 33


State 6

   52 while_stmt: WHILE • @5 LPAREN expression RPAREN @6 LBRACE $@7 statement_list RBRACE

    $default  reduce using rule 49 (@5)

    @5  go to state 34


State 7

   53 for_stmt: FOR • LPAREN for_header SEMI expression SEMI assignment RPAREN for_body
   54         | FOR • error
   55         | FOR • LPAREN for_header SEMI expression SEMI assignment error

    error   shift, and go to state 35
    LPAREN  shift, and go to state 36


State 8

   72 switch_stmt: SWITCH • LPAREN IDENTIFIER RPAREN @9 LBRACE $@10 case_list default_case RBRACE
   73            | SWITCH • error
   74            | SWITCH • LPAREN IDENTIFIER error
   75            | SWITCH • LPAREN IDENTIFIER RPAREN error

    error   shift, and go to state 37
    LPAREN  shift, and go to state 38


State 9

  124 function_decl: FUNCTION • TYPE IDENTIFIER LPAREN params RPAREN LBRACE $@14 statement_list RBRACE

    TYPE  shift, and go to state 39


State 10

   86 return_stmt: RETURN • expression
   87            | RETURN •

    NOT         shift, and go to state 40
    MINUS       shift, and go to state 41
    LPAREN      shift, and go to state 42
    INT         shift, and go to state 43
    FLOAT       shift, and go to state 44
    CHAR        shift, and go to state 45
    BOOLEAN     shift, and go to state 46
    IDENTIFIER  shift, and go to state 47
    STRING      shift, and go to state 48

    $default  reduce using rule 87 (return_stmt)

    expression           go to state 49
    logical_expr         go to state 50
    logical_term         go to state 51
    equality_expr        go to state 52
    relational_expr      go to state 53
    additive_expr        go to state 54
    multiplicative_expr  go to state 55
    exponent_expr        go to state 56
    unary_expr           go to state 57
    primary_expr         go to state 58
    function_call        go to state 59


State 11

  135 const_decl: CONST • TYPE IDENTIFIER ASSIGN expression

    TYPE  shift, and go to state 60


State 12

   16 statement: BREAK • SEMI
   24          | BREAK • error

    error  shift, and go to state 61
    SEMI   shift, and go to state 62


State 13

   15 statement: CONTINUE • SEMI
   23          | CONTINUE • error

    error  shift, and go to state 63
    SEMI   shift, and go to state 64


State 14

   17 statement: LBRACE • statement_list RBRACE

    $default  reduce using rule 2 (statement_list)

    statement_list  go to state 65


State 15

   32 assignment: IDENTIFIER • INC
   33           | IDENTIFIER • DEC
   36           | IDENTIFIER • ASSIGN expression
   37           | IDENTIFIER • ASSIGN error
  125 function_call: IDENTIFIER • LPAREN argument_list RPAREN
  126              | IDENTIFIER • LPAREN RPAREN
  127              | IDENTIFIER • LPAREN error

    ASSIGN  shift, and go to state 66
    LPAREN  shift, and go to state 67
    INC     shift, and go to state 68
    DEC     shift, and go to state 69


State 16

   25 declaration: TYPE • identifier_list
   26            | TYPE • IDENTIFIER ASSIGN expression
   27            | TYPE • error
   28            | TYPE • IDENTIFIER ASSIGN error

    error       shift, and go to state 70
    IDENTIFIER  shift, and go to state 71

    identifier_list  go to state 72


State 17

   34 assignment: INC • IDENTIFIER

    IDENTIFIER  shift, and go to state 73


State 18

   35 assignment: DEC • IDENTIFIER

    IDENTIFIER  shift, and go to state 74


State 19

    3 statement_list: statement_list statement •

    $default  reduce using rule 3 (statement_list)


State 20

    4 statement: declaration • SEMI
   18          | declaration • error

    error  shift, and go to state 75
    SEMI   shift, and go to state 76


State 21

    5 statement: assignment • SEMI
   19          | assignment • error

    error  shift, and go to state 77
    SEMI   shift, and go to state 78


State 22

    6 statement: if_stmt •

    $default  reduce using rule 6 (statement)


State 23

    7 statement: while_stmt •

    $default  reduce using rule 7 (statement)


State 24

    8 statement: for_stmt •

    $default  reduce using rule 8 (statement)


State 25

    9 statement: switch_stmt •

    $default  reduce using rule 9 (statement)


State 26

   10 statement: return_stmt • SEMI
   20          | return_stmt • error

    error  shift, and go to state 79
    SEMI   shift, and go to state 80


State 27

   11 statement: repeat_stmt •

    $default  reduce using rule 11 (statement)


State 28

   12 statement: function_decl •

    $default  reduce using rule 12 (statement)


State 29

   14 statement: function_call • SEMI
   22          | function_call • error

    error  shift, and go to state 81
    SEMI   shift, and go to state 82


State 30

   13 statement: const_decl • SEMI
   21          | const_decl • error

    error  shift, and go to state 83
    SEMI   shift, and go to state 84


State 31

   42 if_stmt: IF error •

    $default  reduce using rule 42 (if_stmt)


State 32

   41 if_stmt: IF LPAREN • expression RPAREN @1 LBRACE $@2 statement_list RBRACE $@3 else_part
   43        | IF LPAREN • expression error
   44        | IF LPAREN • expression RPAREN error

    NOT         shift, and go to state 40
    MINUS       shift, and go to state 41
    LPAREN      shift, and go to state 42
    INT         shift, and go to state 43
    FLOAT       shift, and go to state 44
    CHAR        shift, and go to state 45
    BOOLEAN     shift, and go to state 46
    IDENTIFIER  shift, and go to state 47
    STRING      shift, and go to state 48

    expression           go to state 85
    logical_expr         go to state 50
    logical_term         go to state 51
    equality_expr        go to state 52
    relational_expr      go to state 53
    additive_expr        go to state 54
    multiplicative_expr  go to state 55
    exponent_expr        go to state 56
    unary_expr           go to state 57
    primary_expr         go to state 58
    function_call        go to state 59


State 33

  122 repeat_stmt: REPEAT LBRACE • @13 statement_list RBRACE UNTIL LPAREN expression RPAREN SEMI

    $default  reduce using rule 121 (@13)

    @13  go to state 86


State 34

   52 while_stmt: WHILE @5 • LPAREN expression RPAREN @6 LBRACE $@7 statement_list RBRACE

    LPAREN  shift, and go to state 87


State 35

   54 for_stmt: FOR error •

    $default  reduce using rule 54 (for_stmt)


State 36

   53 for_stmt: FOR LPAREN • for_header SEMI expression SEMI assignment RPAREN for_body
   55         | FOR LPAREN • for_header SEMI expression SEMI assignment error

    IDENTIFIER  shift, and go to state 88
    TYPE        shift, and go to state 89

    for_header            go to state 90
    for_stmt_declaration  go to state 91


State 37

   73 switch_stmt: SWITCH error •

    $default  reduce using rule 73 (switch_stmt)


State 38

   72 switch_stmt: SWITCH LPAREN • IDENTIFIER RPAREN @9 LBRACE $@10 case_list default_case RBRACE
   74            | SWITCH LPAREN • IDENTIFIER error
   75            | SWITCH LPAREN • IDENTIFIER RPAREN error

    IDENTIFIER  shift, and go to state 92


State 39

  124 function_decl: FUNCTION TYPE • IDENTIFIER LPAREN params RPAREN LBRACE $@14 statement_list RBRACE

    IDENTIFIER  shift, and go to state 93


State 40

  111 unary_expr: NOT • unary_expr

    NOT         shift, and go to state 40
    MINUS       shift, and go to state 41
    LPAREN      shift, and go to state 42
    INT         shift, and go to state 43
    FLOAT       shift, and go to state 44
    CHAR        shift, and go to state 45
    BOOLEAN     shift, and go to state 46
    IDENTIFIER  shift, and go to state 47
    STRING      shift, and go to state 48

    unary_expr     go to state 94
    primary_expr   go to state 58
    function_call  go to state 59


State 41

  110 unary_expr: MINUS • unary_expr

    NOT         shift, and go to state 40
    MINUS       shift, and go to state 41
    LPAREN      shift, and go to state 42
    INT         shift, and go to state 43
    FLOAT       shift, and go to state 44
    CHAR        shift, and go to state 45
    BOOLEAN     shift, and go to state 46
    IDENTIFIER  shift, and go to state 47
    STRING      shift, and go to state 48

    unary_expr     go to state 95
    primary_expr   go to state 58
    function_call  go to state 59


State 42

  118 primary_expr: LPAREN • expression RPAREN

    NOT         shift, and go to state 40
    MINUS       shift, and go to state 41
    LPAREN      shift, and go to state 42
    INT         shift, and go to state 43
    FLOAT       shift, and go to state 44
    CHAR        shift, and go to state 45
    BOOLEAN     shift, and go to state 46
    IDENTIFIER  shift, and go to state 47
    STRING      shift, and go to state 48

    expression           go to state 96
    logical_expr         go to state 50
    logical_term         go to state 51
    equality_expr        go to state 52
    relational_expr      go to state 53
    additive_expr        go to state 54
    multiplicative_expr  go to state 55
    exponent_expr        go to state 56
    unary_expr           go to state 57
    primary_expr         go to state 58
    function_call        go to state 59


State 43

  113 primary_expr: INT •

    $default  reduce using rule 113 (primary_expr)


State 44

  114 primary_expr: FLOAT •

    $default  reduce using rule 114 (primary_expr)


State 45

  115 primary_expr: CHAR •

    $default  reduce using rule 115 (primary_expr)


State 46

  116 primary_expr: BOOLEAN •

    $default  reduce using rule 116 (primary_expr)


State 47

  120 primary_expr: IDENTIFIER •
  125 function_call: IDENTIFIER • LPAREN argument_list RPAREN
  126              | IDENTIFIER • LPAREN RPAREN
  127              | IDENTIFIER • LPAREN error

    LPAREN  shift, and go to state 67

    $default  reduce using rule 120 (primary_expr)


State 48

  117 primary_expr: STRING •

    $default  reduce using rule 117 (primary_expr)


State 49

   86 return_stmt: RETURN expression •

    $default  reduce using rule 86 (return_stmt)


State 50

   88 expression: logical_expr •
   89 logical_expr: logical_expr • OR logical_term

    OR  shift, and go to state 97

    $default  reduce using rule 88 (expression)


State 51

   90 logical_expr: logical_term •
   91 logical_term: logical_term • AND equality_expr

    AND  shift, and go to state 98

    $default  reduce using rule 90 (logical_expr)


State 52

   92 logical_term: equality_expr •
   93 equality_expr: equality_expr • EQ relational_expr
   94              | equality_expr • NEQ relational_expr

    EQ   shift, and go to state 99
    NEQ  shift, and go to state 100

    $default  reduce using rule 92 (logical_term)


State 53

   95 equality_expr: relational_expr •
   96 relational_expr: relational_expr • LT additive_expr
   97                | relational_expr • GT additive_expr
   98                | relational_expr • LTE additive_expr
   99                | relational_expr • GTE additive_expr

    GTE  shift, and go to state 101
    LTE  shift, and go to state 102
    GT   shift, and go to state 103
    LT   shift, and go to state 104

    $default  reduce using rule 95 (equality_expr)


State 54

  100 relational_expr: additive_expr •
  101 additive_expr: additive_expr • PLUS multiplicative_expr
  102              | additive_expr • MINUS multiplicative_expr

    PLUS   shift, and go to state 105
    MINUS  shift, and go to state 106

    $default  reduce using rule 100 (relational_expr)


State 55

  103 additive_expr: multiplicative_expr •
  104 multiplicative_expr: multiplicative_expr • MUL exponent_expr
  105                    | multiplicative_expr • DIV exponent_expr
  106                    | multiplicative_expr • MOD exponent_expr

    MUL  shift, and go to state 107
    DIV  shift, and go to state 108
    MOD  shift, and go to state 109

    $default  reduce using rule 103 (additive_expr)


State 56

  107 multiplicative_expr: exponent_expr •
  108 exponent_expr: exponent_expr • EXP unary_expr

    EXP  shift, and go to state 110

    $default  reduce using rule 107 (multiplicative_expr)


State 57

  109 exponent_expr: unary_expr •

    $default  reduce using rule 109 (exponent_expr)


State 58

  112 unary_expr: primary_expr •

    $default  reduce using rule 112 (unary_expr)


State 59

  119 primary_expr: function_call •

    $default  reduce using rule 119 (primary_expr)


State 60

  135 const_decl: CONST TYPE • IDENTIFIER ASSIGN expression

    IDENTIFIER  shift, and go to state 111


State 61

   24 statement: BREAK error •

    $default  reduce using rule 24 (statement)


State 62

   16 statement: BREAK SEMI •

    $default  reduce using rule 16 (statement)


State 63

   23 statement: CONTINUE error •

    $default  reduce using rule 23 (statement)


State 64

   15 statement: CONTINUE SEMI •

    $default  reduce using rule 15 (statement)


State 65

    3 statement_list: statement_list • statement
   17 statement: LBRACE statement_list • RBRACE

    IF          shift, and go to state 4
    REPEAT      shift, and go to state 5
    WHILE       shift, and go to state 6
    FOR         shift, and go to state 7
    SWITCH      shift, and go to state 8
    FUNCTION    shift, and go to state 9
    RETURN      shift, and go to state 10
    CONST       shift, and go to state 11
    BREAK       shift, and go to state 12
    CONTINUE    shift, and go to state 13
    LBRACE      shift, and go to state 14
    RBRACE      shift, and go to state 112
    IDENTIFIER  shift, and go to state 15
    TYPE        shift, and go to state 16
    INC         shift, and go to state 17
    DEC         shift, and go to state 18

    statement      go to state 19
    declaration    go to state 20
    assignment     go to state 21
    if_stmt        go to state 22
    while_stmt     go to state 23
    for_stmt       go to state 24
    switch_stmt    go to state 25
    return_stmt    go to state 26
    repeat_stmt    go to state 27
    function_decl  go to state 28
    function_call  go to state 29
    const_decl     go to state 30


State 66

   36 assignment: IDENTIFIER ASSIGN • expression
   37           | IDENTIFIER ASSIGN • error

    error       shift, and go to state 113
    NOT         shift, and go to state 40
    MINUS       shift, and go to state 41
    LPAREN      shift, and go to state 42
    INT         shift, and go to state 43
    FLOAT       shift, and go to state 44
    CHAR        shift, and go to state 45
    BOOLEAN     shift, and go to state 46
    IDENTIFIER  shift, and go to state 47
    STRING      shift, and go to state 48

    expression           go to state 114
    logical_expr         go to state 50
    logical_term         go to state 51
    equality_expr        go to state 52
    relational_expr      go to state 53
    additive_expr        go to state 54
    multiplicative_expr  go to state 55
    exponent_expr        go to state 56
    unary_expr           go to state 57
    primary_expr         go to state 58
    function_call        go to state 59


State 67

  125 function_call: IDENTIFIER LPAREN • argument_list RPAREN
  126              | IDENTIFIER LPAREN • RPAREN
  127              | IDENTIFIER LPAREN • error

    error       shift, and go to state 115
    NOT         shift, and go to state 40
    MINUS       shift, and go to state 41
    LPAREN      shift, and go to state 42
    RPAREN      shift, and go to state 116
    INT         shift, and go to state 43
    FLOAT       shift, and go to state 44
    CHAR        shift, and go to state 45
    BOOLEAN     shift, and go to state 46
    IDENTIFIER  shift, and go to state 47
    STRING      shift, and go to state 48

    expression           go to state 117
    logical_expr         go to state 50
    logical_term         go to state 51
    equality_expr        go to state 52
    relational_expr      go to state 53
    additive_expr        go to state 54
    multiplicative_expr  go to state 55
    exponent_expr        go to state 56
    unary_expr           go to state 57
    primary_expr         go to state 58
    function_call        go to state 59
    argument_list        go to state 118


State 68

   32 assignment: IDENTIFIER INC •

    $default  reduce using rule 32 (assignment)


State 69

   33 assignment: IDENTIFIER DEC •

    $default  reduce using rule 33 (assignment)


State 70

   27 declaration: TYPE error •

    $default  reduce using rule 27 (declaration)


State 71

   26 declaration: TYPE IDENTIFIER • ASSIGN expression
   28            | TYPE IDENTIFIER • ASSIGN error
   29 identifier_list: IDENTIFIER •

    ASSIGN  shift, and go to state 119

    $default  reduce using rule 29 (identifier_list)


State 72

   25 declaration: TYPE identifier_list •
   30 identifier_list: identifier_list • COMMA IDENTIFIER
   31                | identifier_list • COMMA error

    COMMA  shift, and go to state 120

    $default  reduce using rule 25 (declaration)


State 73

   34 assignment: INC IDENTIFIER •

    $default  reduce using rule 34 (assignment)


State 74

   35 assignment: DEC IDENTIFIER •

    $default  reduce using rule 35 (assignment)


State 75

   18 statement: declaration error •

    $default  reduce using rule 18 (statement)


State 76

    4 statement: declaration SEMI •

    $default  reduce using rule 4 (statement)


State 77

   19 statement: assignment error •

    $default  reduce using rule 19 (statement)


State 78

    5 statement: assignment SEMI •

    $default  reduce using rule 5 (statement)


State 79

   20 statement: return_stmt error •

    $default  reduce using rule 20 (statement)


State 80

   10 statement: return_stmt SEMI •

    $default  reduce using rule 10 (statement)


State 81

   22 statement: function_call error •

    $default  reduce using rule 22 (statement)


State 82

   14 statement: function_call SEMI •

    $default  reduce using rule 14 (statement)


State 83

   21 statement: const_decl error •

    $default  reduce using rule 21 (statement)


State 84

   13 statement: const_decl SEMI •

    $default  reduce using rule 13 (statement)


State 85

   41 if_stmt: IF LPAREN expression • RPAREN @1 LBRACE $@2 statement_list RBRACE $@3 else_part
   43        | IF LPAREN expression • error
   44        | IF LPAREN expression • RPAREN error

    error   shift, and go to state 121
    RPAREN  shift, and go to state 122


State 86

  122 repeat_stmt: REPEAT LBRACE @13 • statement_list RBRACE UNTIL LPAREN expression RPAREN SEMI

    $default  reduce using rule 2 (statement_list)

    statement_list  go to state 123


State 87

   52 while_stmt: WHILE @5 LPAREN • expression RPAREN @6 LBRACE $@7 statement_list RBRACE

    NOT         shift, and go to state 40
    MINUS       shift, and go to state 41
    LPAREN      shift, and go to state 42
    INT         shift, and go to state 43
    FLOAT       shift, and go to state 44
    CHAR        shift, and go to state 45
    BOOLEAN     shift, and go to state 46
    IDENTIFIER  shift, and go to state 47
    STRING      shift, and go to state 48

    expression           go to state 124
    logical_expr         go to state 50
    logical_term         go to state 51
    equality_expr        go to state 52
    relational_expr      go to state 53
    additive_expr        go to state 54
    multiplicative_expr  go to state 55
    exponent_expr        go to state 56
    unary_expr           go to state 57
    primary_expr         go to state 58
    function_call        go to state 59


State 88

   62 for_stmt_declaration: IDENTIFIER • ASSIGN expression
   65                     | IDENTIFIER • ASSIGN error

    ASSIGN  shift, and go to state 125


State 89

   60 for_stmt_declaration: TYPE • IDENTIFIER ASSIGN expression
   61                     | TYPE • IDENTIFIER
   63                     | TYPE • error
   64                     | TYPE • IDENTIFIER ASSIGN error

    error       shift, and go to state 126
    IDENTIFIER  shift, and go to state 127


State 90

   53 for_stmt: FOR LPAREN for_header • SEMI expression SEMI assignment RPAREN for_body
   55         | FOR LPAREN for_header • SEMI expression SEMI assignment error

    SEMI  shift, and go to state 128


State 91

   56 for_header: for_stmt_declaration •
   57           | for_stmt_declaration • error

    error  shift, and go to state 129

    SEMI  reduce using rule 56 (for_header)


State 92

   72 switch_stmt: SWITCH LPAREN IDENTIFIER • RPAREN @9 LBRACE $@10 case_list default_case RBRACE
   74            | SWITCH LPAREN IDENTIFIER • error
   75            | SWITCH LPAREN IDENTIFIER • RPAREN error

    error   shift, and go to state 130
    RPAREN  shift, and go to state 131


State 93

  124 function_decl: FUNCTION TYPE IDENTIFIER • LPAREN params RPAREN LBRACE $@14 statement_list RBRACE

    LPAREN  shift, and go to state 132


State 94

  111 unary_expr: NOT unary_expr •

    $default  reduce using rule 111 (unary_expr)


State 95

  110 unary_expr: MINUS unary_expr •

    $default  reduce using rule 110 (unary_expr)


State 96

  118 primary_expr: LPAREN expression • RPAREN

    RPAREN  shift, and go to state 133


State 97

   89 logical_expr: logical_expr OR • logical_term

    NOT         shift, and go to state 40
    MINUS       shift, and go to state 41
    LPAREN      shift, and go to state 42
    INT         shift, and go to state 43
    FLOAT       shift, and go to state 44
    CHAR        shift, and go to state 45
    BOOLEAN     shift, and go to state 46
    IDENTIFIER  shift, and go to state 47
    STRING      shift, and go to state 48

    logical_term         go to state 134
    equality_expr        go to state 52
    relational_expr      go to state 53
    additive_expr        go to state 54
    multiplicative_expr  go to state 55
    exponent_expr        go to state 56
    unary_expr           go to state 57
    primary_expr         go to state 58
    function_call        go to state 59


State 98

   91 logical_term: logical_term AND • equality_expr

    NOT         shift, and go to state 40
    MINUS       shift, and go to state 41
    LPAREN      shift, and go to state 42
    INT         shift, and go to state 43
    FLOAT       shift, and go to state 44
    CHAR        shift, and go to state 45
    BOOLEAN     shift, and go to state 46
    IDENTIFIER  shift, and go to state 47
    STRING      shift, and go to state 48

    equality_expr        go to state 135
    relational_expr      go to state 53
    additive_expr        go to state 54
    multiplicative_expr  go to state 55
    exponent_expr        go to state 56
    unary_expr           go to state 57
    primary_expr         go to state 58
    function_call        go to state 59


State 99

   93 equality_expr: equality_expr EQ • relational_expr

    NOT         shift, and go to state 40
    MINUS       shift, and go to state 41
    LPAREN      shift, and go to state 42
    INT         shift, and go to state 43
    FLOAT       shift, and go to state 44
    CHAR        shift, and go to state 45
    BOOLEAN     shift, and go to state 46
    IDENTIFIER  shift, and go to state 47
    STRING      shift, and go to state 48

    relational_expr      go to state 136
    additive_expr        go to state 54
    multiplicative_expr  go to state 55
    exponent_expr        go to state 56
    unary_expr           go to state 57
    primary_expr         go to state 58
    function_call        go to state 59


State 100

   94 equality_expr: equality_expr NEQ • relational_expr

    NOT         shift, and go to state 40
    MINUS       shift, and go to state 41
    LPAREN      shift, and go to state 42
    INT         shift, and go to state 43
    FLOAT       shift, and go to state 44
    CHAR        shift, and go to state 45
    BOOLEAN     shift, and go to state 46
    IDENTIFIER  shift, and go to state 47
    STRING      shift, and go to state 48

    relational_expr      go to state 137
    additive_expr        go to state 54
    multiplicative_expr  go to state 55
    exponent_expr        go to state 56
    unary_expr           go to state 57
    primary_expr         go to state 58
    function_call        go to state 59


State 101

   99 relational_expr: relational_expr GTE • additive_expr

    NOT         shift, and go to state 40
    MINUS       shift, and go to state 41
    LPAREN      shift, and go to state 42
    INT         shift, and go to state 43
    FLOAT       shift, and go to state 44
    CHAR        shift, and go to state 45
    BOOLEAN     shift, and go to state 46
    IDENTIFIER  shift, and go to state 47
    STRING      shift, and go to state 48

    additive_expr        go to state 138
    multiplicative_expr  go to state 55
    exponent_expr        go to state 56
    unary_expr           go to state 57
    primary_expr         go to state 58
    function_call        go to state 59


State 102

   98 relational_expr: relational_expr LTE • additive_expr

    NOT         shift, and go to state 40
    MINUS       shift, and go to state 41
    LPAREN      shift, and go to state 42
    INT         shift, and go to state 43
    FLOAT       shift, and go to state 44
    CHAR        shift, and go to state 45
    BOOLEAN     shift, and go to state 46
    IDENTIFIER  shift, and go to state 47
    STRING      shift, and go to state 48

    additive_expr        go to state 139
    multiplicative_expr  go to state 55
    exponent_expr        go to state 56
    unary_expr           go to state 57
    primary_expr         go to state 58
    function_call        go to state 59


State 103

   97 relational_expr: relational_expr GT • additive_expr

    NOT         shift, and go to state 40
    MINUS       shift, and go to state 41
    LPAREN      shift, and go to state 42
    INT         shift, and go to state 43
    FLOAT       shift, and go to state 44
    CHAR        shift, and go to state 45
    BOOLEAN     shift, and go to state 46
    IDENTIFIER  shift, and go to state 47
    STRING      shift, and go to state 48

    additive_expr        go to state 140
    multiplicative_expr  go to state 55
    exponent_expr        go to state 56
    unary_expr           go to state 57
    primary_expr         go to state 58
    function_call        go to state 59


State 104

   96 relational_expr: relational_expr LT • additive_expr

    NOT         shift, and go to state 40
    MINUS       shift, and go to state 41
    LPAREN      shift, and go to state 42
    INT         shift, and go to state 43
    FLOAT       shift, and go to state 44
    CHAR        shift, and go to state 45
    BOOLEAN     shift, and go to state 46
    IDENTIFIER  shift, and go to state 47
    STRING      shift, and go to state 48

    additive_expr        go to state 141
    multiplicative_expr  go to state 55
    exponent_expr        go to state 56
    unary_expr           go to state 57
    primary_expr         go to state 58
    function_call        go to state 59


State 105

  101 additive_expr: additive_expr PLUS • multiplicative_expr

    NOT         shift, and go to state 40
    MINUS       shift, and go to state 41
    LPAREN      shift, and go to state 42
    INT         shift, and go to state 43
    FLOAT       shift, and go to state 44
    CHAR        shift, and go to state 45
    BOOLEAN     shift, and go to state 46
    IDENTIFIER  shift, and go to state 47
    STRING      shift, and go to state 48

    multiplicative_expr  go to state 142
    exponent_expr        go to state 56
    unary_expr           go to state 57
    primary_expr         go to state 58
    function_call        go to state 59


State 106

  102 additive_expr: additive_expr MINUS • multiplicative_expr

    NOT         shift, and go to state 40
    MINUS       shift, and go to state 41
    LPAREN      shift, and go to state 42
    INT         shift, and go to state 43
    FLOAT       shift, and go to state 44
    CHAR        shift, and go to state 45
    BOOLEAN     shift, and go to state 46
    IDENTIFIER  shift, and go to state 47
    STRING      shift, and go to state 48

    multiplicative_expr  go to state 143
    exponent_expr        go to state 56
    unary_expr           go to state 57
    primary_expr         go to state 58
    function_call        go to state 59


State 107

  104 multiplicative_expr: multiplicative_expr MUL • exponent_expr

    NOT         shift, and go to state 40
    MINUS       shift, and go to state 41
    LPAREN      shift, and go to state 42
    INT         shift, and go to state 43
    FLOAT       shift, and go to state 44
    CHAR        shift, and go to state 45
    BOOLEAN     shift, and go to state 46
    IDENTIFIER  shift, and go to state 47
    STRING      shift, and go to state 48

    exponent_expr  go to state 144
    unary_expr     go to state 57
    primary_expr   go to state 58
    function_call  go to state 59


State 108

  105 multiplicative_expr: multiplicative_expr DIV • exponent_expr

    NOT         shift, and go to state 40
    MINUS       shift, and go to state 41
    LPAREN      shift, and go to state 42
    INT         shift, and go to state 43
    FLOAT       shift, and go to state 44
    CHAR        shift, and go to state 45
    BOOLEAN     shift, and go to state 46
    IDENTIFIER  shift, and go to state 47
    STRING      shift, and go to state 48

    exponent_expr  go to state 145
    unary_expr     go to state 57
    primary_expr   go to state 58
    function_call  go to state 59


State 109

  106 multiplicative_expr: multiplicative_expr MOD • exponent_expr

    NOT         shift, and go to state 40
    MINUS       shift, and go to state 41
    LPAREN      shift, and go to state 42
    INT         shift, and go to state 43
    FLOAT       shift, and go to state 44
    CHAR        shift, and go to state 45
    BOOLEAN     shift, and go to state 46
    IDENTIFIER  shift, and go to state 47
    STRING      shift, and go to state 48

    exponent_expr  go to state 146
    unary_expr     go to state 57
    primary_expr   go to state 58
    function_call  go to state 59


State 110

  108 exponent_expr: exponent_expr EXP • unary_expr

    NOT         shift, and go to state 40
    MINUS       shift, and go to state 41
    LPAREN      shift, and go to state 42
    INT         shift, and go to state 43
    FLOAT       shift, and go to state 44
    CHAR        shift, and go to state 45
    BOOLEAN     shift, and go to state 46
    IDENTIFIER  shift, and go to state 47
    STRING      shift, and go to state 48

    unary_expr     go to state 147
    primary_expr   go to state 58
    function_call  go to state 59


State 111

  135 const_decl: CONST TYPE IDENTIFIER • ASSIGN expression

    ASSIGN  shift, and go to state 148


State 112

   17 statement: LBRACE statement_list RBRACE •

    $default  reduce using rule 17 (statement)


State 113

   37 assignment: IDENTIFIER ASSIGN error •

    $default  reduce using rule 37 (assignment)


State 114

   36 assignment: IDENTIFIER ASSIGN expression •

    $default  reduce using rule 36 (assignment)


State 115

  127 function_call: IDENTIFIER LPAREN error •

    $default  reduce using rule 127 (function_call)


State 116

  126 function_call: IDENTIFIER LPAREN RPAREN •

    $default  reduce using rule 126 (function_call)


State 117

  129 argument_list: expression •

    $default  reduce using rule 129 (argument_list)


State 118

  125 function_call: IDENTIFIER LPAREN argument_list • RPAREN
  128 argument_list: argument_list • COMMA expression

    COMMA   shift, and go to state 149
    RPAREN  shift, and go to state 150


State 119

   26 declaration: TYPE IDENTIFIER ASSIGN • expression
   28            | TYPE IDENTIFIER ASSIGN • error

    error       shift, and go to state 151
    NOT         shift, and go to state 40
    MINUS       shift, and go to state 41
    LPAREN      shift, and go to state 42
    INT         shift, and go to state 43
    FLOAT       shift, and go to state 44
    CHAR        shift, and go to state 45
    BOOLEAN     shift, and go to state 46
    IDENTIFIER  shift, and go to state 47
    STRING      shift, and go to state 48

    expression           go to state 152
    logical_expr         go to state 50
    logical_term         go to state 51
    equality_expr        go to state 52
    relational_expr      go to state 53
    additive_expr        go to state 54
    multiplicative_expr  go to state 55
    exponent_expr        go to state 56
    unary_expr           go to state 57
    primary_expr         go to state 58
    function_call        go to state 59


State 120

   30 identifier_list: identifier_list COMMA • IDENTIFIER
   31                | identifier_list COMMA • error

    error       shift, and go to state 153
    IDENTIFIER  shift, and go to state 154


State 121

   43 if_stmt: IF LPAREN expression error •

    $default  reduce using rule 43 (if_stmt)


State 122

   41 if_stmt: IF LPAREN expression RPAREN • @1 LBRACE $@2 statement_list RBRACE $@3 else_part
   44        | IF LPAREN expression RPAREN • error

    error  shift, and go to state 155

    LBRACE  reduce using rule 38 (@1)

    @1  go to state 156


State 123

    3 statement_list: statement_list • statement
  122 repeat_stmt: REPEAT LBRACE @13 statement_list • RBRACE UNTIL LPAREN expression RPAREN SEMI

    IF          shift, and go to state 4
    REPEAT      shift, and go to state 5
    WHILE       shift, and go to state 6
    FOR         shift, and go to state 7
    SWITCH      shift, and go to state 8
    FUNCTION    shift, and go to state 9
    RETURN      shift, and go to state 10
    CONST       shift, and go to state 11
    BREAK       shift, and go to state 12
    CONTINUE    shift, and go to state 13
    LBRACE      shift, and go to state 14
    RBRACE      shift, and go to state 157
    IDENTIFIER  shift, and go to state 15
    TYPE        shift, and go to state 16
    INC         shift, and go to state 17
    DEC         shift, and go to state 18

    statement      go to state 19
    declaration    go to state 20
    assignment     go to state 21
    if_stmt        go to state 22
    while_stmt     go to state 23
    for_stmt       go to state 24
    switch_stmt    go to state 25
    return_stmt    go to state 26
    repeat_stmt    go to state 27
    function_decl  go to state 28
    function_call  go to state 29
    const_decl     go to state 30


State 124

   52 while_stmt: WHILE @5 LPAREN expression • RPAREN @6 LBRACE $@7 statement_list RBRACE

    RPAREN  shift, and go to state 158


State 125

   62 for_stmt_declaration: IDENTIFIER ASSIGN • expression
   65                     | IDENTIFIER ASSIGN • error

    error       shift, and go to state 159
    NOT         shift, and go to state 40
    MINUS       shift, and go to state 41
    LPAREN      shift, and go to state 42
    INT         shift, and go to state 43
    FLOAT       shift, and go to state 44
    CHAR        shift, and go to state 45
    BOOLEAN     shift, and go to state 46
    IDENTIFIER  shift, and go to state 47
    STRING      shift, and go to state 48

    expression           go to state 160
    logical_expr         go to state 50
    logical_term         go to state 51
    equality_expr        go to state 52
    relational_expr      go to state 53
    additive_expr        go to state 54
    multiplicative_expr  go to state 55
    exponent_expr        go to state 56
    unary_expr           go to state 57
    primary_expr         go to state 58
    function_call        go to state 59


State 126

   63 for_stmt_declaration: TYPE error •

    $default  reduce using rule 63 (for_stmt_declaration)


State 127

   60 for_stmt_declaration: TYPE IDENTIFIER • ASSIGN expression
   61                     | TYPE IDENTIFIER •
   64                     | TYPE IDENTIFIER • ASSIGN error

    ASSIGN  shift, and go to state 161

    $default  reduce using rule 61 (for_stmt_declaration)


State 128

   53 for_stmt: FOR LPAREN for_header SEMI • expression SEMI assignment RPAREN for_body
   55         | FOR LPAREN for_header SEMI • expression SEMI assignment error

    NOT         shift, and go to state 40
    MINUS       shift, and go to state 41
    LPAREN      shift, and go to state 42
    INT         shift, and go to state 43
    FLOAT       shift, and go to state 44
    CHAR        shift, and go to state 45
    BOOLEAN     shift, and go to state 46
    IDENTIFIER  shift, and go to state 47
    STRING      shift, and go to state 48

    expression           go to state 162
    logical_expr         go to state 50
    logical_term         go to state 51
    equality_expr        go to state 52
    relational_expr      go to state 53
    additive_expr        go to state 54
    multiplicative_expr  go to state 55
    exponent_expr        go to state 56
    unary_expr           go to state 57
    primary_expr         go to state 58
    function_call        go to state 59


State 129

   57 for_header: for_stmt_declaration error •

    $default  reduce using rule 57 (for_header)


State 130

   74 switch_stmt: SWITCH LPAREN IDENTIFIER error •

    $default  reduce using rule 74 (switch_stmt)


State 131

   72 switch_stmt: SWITCH LPAREN IDENTIFIER RPAREN • @9 LBRACE $@10 case_list default_case RBRACE
   75            | SWITCH LPAREN IDENTIFIER RPAREN • error

    error  shift, and go to state 163

    LBRACE  reduce using rule 70 (@9)

    @9  go to state 164


State 132

  124 function_decl: FUNCTION TYPE IDENTIFIER LPAREN • params RPAREN LBRACE $@14 statement_list RBRACE

    TYPE  shift, and go to state 165

    $default  reduce using rule 130 (params)

    params      go to state 166
    param_list  go to state 167
    param       go to state 168


State 133

  118 primary_expr: LPAREN expression RPAREN •

    $default  reduce using rule 118 (primary_expr)


State 134

   89 logical_expr: logical_expr OR logical_term •
   91 logical_term: logical_term • AND equality_expr

    AND  shift, and go to state 98

    $default  reduce using rule 89 (logical_expr)


State 135

   91 logical_term: logical_term AND equality_expr •
   93 equality_expr: equality_expr • EQ relational_expr
   94              | equality_expr • NEQ relational_expr

    EQ   shift, and go to state 99
    NEQ  shift, and go to state 100

    $default  reduce using rule 91 (logical_term)


State 136

   93 equality_expr: equality_expr EQ relational_expr •
   96 relational_expr: relational_expr • LT additive_expr
   97                | relational_expr • GT additive_expr
   98                | relational_expr • LTE additive_expr
   99                | relational_expr • GTE additive_expr

    GTE  shift, and go to state 101
    LTE  shift, and go to state 102
    GT   shift, and go to state 103
    LT   shift, and go to state 104

    $default  reduce using rule 93 (equality_expr)


State 137

   94 equality_expr: equality_expr NEQ relational_expr •
   96 relational_expr: relational_expr • LT additive_expr
   97                | relational_expr • GT additive_expr
   98                | relational_expr • LTE additive_expr
   99                | relational_expr • GTE additive_expr

    GTE  shift, and go to state 101
    LTE  shift, and go to state 102
    GT   shift, and go to state 103
    LT   shift, and go to state 104

    $default  reduce using rule 94 (equality_expr)


State 138

   99 relational_expr: relational_expr GTE additive_expr •
  101 additive_expr: additive_expr • PLUS multiplicative_expr
  102              | additive_expr • MINUS multiplicative_expr

    PLUS   shift, and go to state 105
    MINUS  shift, and go to state 106

    $default  reduce using rule 99 (relational_expr)


State 139

   98 relational_expr: relational_expr LTE additive_expr •
  101 additive_expr: additive_expr • PLUS multiplicative_expr
  102              | additive_expr • MINUS multiplicative_expr

    PLUS   shift, and go to state 105
    MINUS  shift, and go to state 106

    $default  reduce using rule 98 (relational_expr)


State 140

   97 relational_expr: relational_expr GT additive_expr •
  101 additive_expr: additive_expr • PLUS multiplicative_expr
  102              | additive_expr • MINUS multiplicative_expr

    PLUS   shift, and go to state 105
    MINUS  shift, and go to state 106

    $default  reduce using rule 97 (relational_expr)


State 141

   96 relational_expr: relational_expr LT additive_expr •
  101 additive_expr: additive_expr • PLUS multiplicative_expr
  102              | additive_expr • MINUS multiplicative_expr

    PLUS   shift, and go to state 105
    MINUS  shift, and go to state 106

    $default  reduce using rule 96 (relational_expr)


State 142

  101 additive_expr: additive_expr PLUS multiplicative_expr •
  104 multiplicative_expr: multiplicative_expr • MUL exponent_expr
  105                    | multiplicative_expr • DIV exponent_expr
  106                    | multiplicative_expr • MOD exponent_expr

    MUL  shift, and go to state 107
    DIV  shift, and go to state 108
    MOD  shift, and go to state 109

    $default  reduce using rule 101 (additive_expr)


State 143

  102 additive_expr: additive_expr MINUS multiplicative_expr •
  104 multiplicative_expr: multiplicative_expr • MUL exponent_expr
  105                    | multiplicative_expr • DIV exponent_expr
  106                    | multiplicative_expr • MOD exponent_expr

    MUL  shift, and go to state 107
    DIV  shift, and go to state 108
    MOD  shift, and go to state 109

    $default  reduce using rule 102 (additive_expr)


State 144

  104 multiplicative_expr: multiplicative_expr MUL exponent_expr •
  108 exponent_expr: exponent_expr • EXP unary_expr

    EXP  shift, and go to state 110

    $default  reduce using rule 104 (multiplicative_expr)


State 145

  105 multiplicative_expr: multiplicative_expr DIV exponent_expr •
  108 exponent_expr: exponent_expr • EXP unary_expr

    EXP  shift, and go to state 110

    $default  reduce using rule 105 (multiplicative_expr)


State 146

  106 multiplicative_expr: multiplicative_expr MOD exponent_expr •
  108 exponent_expr: exponent_expr • EXP unary_expr

    EXP  shift, and go to state 110

    $default  reduce using rule 106 (multiplicative_expr)


State 147

  108 exponent_expr: exponent_expr EXP unary_expr •

    $default  reduce using rule 108 (exponent_expr)


State 148

  135 const_decl: CONST TYPE IDENTIFIER ASSIGN • expression

    NOT         shift, and go to state 40
    MINUS       shift, and go to state 41
    LPAREN      shift, and go to state 42
    INT         shift, and go to state 43
    FLOAT       shift, and go to state 44
    CHAR        shift, and go to state 45
    BOOLEAN     shift, and go to state 46
    IDENTIFIER  shift, and go to state 47
    STRING      shift, and go to state 48

    expression           go to state 169
    logical_expr         go to state 50
    logical_term         go to state 51
    equality_expr        go to state 52
    relational_expr      go to state 53
    additive_expr        go to state 54
    multiplicative_expr  go to state 55
    exponent_expr        go to state 56
    unary_expr           go to state 57
    primary_expr         go to state 58
    function_call        go to state 59


State 149

  128 argument_list: argument_list COMMA • expression

    NOT         shift, and go to state 40
    MINUS       shift, and go to state 41
    LPAREN      shift, and go to state 42
    INT         shift, and go to state 43
    FLOAT       shift, and go to state 44
    CHAR        shift, and go to state 45
    BOOLEAN     shift, and go to state 46
    IDENTIFIER  shift, and go to state 47
    STRING      shift, and go to state 48

    expression           go to state 170
    logical_expr         go to state 50
    logical_term         go to state 51
    equality_expr        go to state 52
    relational_expr      go to state 53
    additive_expr        go to state 54
    multiplicative_expr  go to state 55
    exponent_expr        go to state 56
    unary_expr           go to state 57
    primary_expr         go to state 58
    function_call        go to state 59


State 150

  125 function_call: IDENTIFIER LPAREN argument_list RPAREN •

    $default  reduce using rule 125 (function_call)


State 151

   28 declaration: TYPE IDENTIFIER ASSIGN error •

    $default  reduce using rule 28 (declaration)


State 152

   26 declaration: TYPE IDENTIFIER ASSIGN expression •

    $default  reduce using rule 26 (declaration)


State 153

   31 identifier_list: identifier_list COMMA error •

    $default  reduce using rule 31 (identifier_list)


State 154

   30 identifier_list: identifier_list COMMA IDENTIFIER •

    $default  reduce using rule 30 (identifier_list)


State 155

   44 if_stmt: IF LPAREN expression RPAREN error •

    $default  reduce using rule 44 (if_stmt)


State 156

   41 if_stmt: IF LPAREN expression RPAREN @1 • LBRACE $@2 statement_list RBRACE $@3 else_part

    LBRACE  shift, and go to state 171


State 157

  122 repeat_stmt: REPEAT LBRACE @13 statement_list RBRACE • UNTIL LPAREN expression RPAREN SEMI

    UNTIL  shift, and go to state 172


State 158

   52 while_stmt: WHILE @5 LPAREN expression RPAREN • @6 LBRACE $@7 statement_list RBRACE

    $default  reduce using rule 50 (@6)

    @6  go to state 173


State 159

   65 for_stmt_declaration: IDENTIFIER ASSIGN error •

    $default  reduce using rule 65 (for_stmt_declaration)


State 160

   62 for_stmt_declaration: IDENTIFIER ASSIGN expression •

    $default  reduce using rule 62 (for_stmt_declaration)


State 161

   60 for_stmt_declaration: TYPE IDENTIFIER ASSIGN • expression
   64                     | TYPE IDENTIFIER ASSIGN • error

    error       shift, and go to state 174
    NOT         shift, and go to state 40
    MINUS       shift, and go to state 41
    LPAREN      shift, and go to state 42
    INT         shift, and go to state 43
    FLOAT       shift, and go to state 44
    CHAR        shift, and go to state 45
    BOOLEAN     shift, and go to state 46
    IDENTIFIER  shift, and go to state 47
    STRING      shift, and go to state 48

    expression           go to state 175
    logical_expr         go to state 50
    logical_term         go to state 51
    equality_expr        go to state 52
    relational_expr      go to state 53
    additive_expr        go to state 54
    multiplicative_expr  go to state 55
    exponent_expr        go to state 56
    unary_expr           go to state 57
    primary_expr         go to state 58
    function_call        go to state 59


State 162

   53 for_stmt: FOR LPAREN for_header SEMI expression • SEMI assignment RPAREN for_body
   55         | FOR LPAREN for_header SEMI expression • SEMI assignment error

    SEMI  shift, and go to state 176


State 163

   75 switch_stmt: SWITCH LPAREN IDENTIFIER RPAREN error •

    $default  reduce using rule 75 (switch_stmt)


State 164

   72 switch_stmt: SWITCH LPAREN IDENTIFIER RPAREN @9 • LBRACE $@10 case_list default_case RBRACE

    LBRACE  shift, and go to state 177


State 165

  134 param: TYPE • IDENTIFIER

    IDENTIFIER  shift, and go to state 178


State 166

  124 function_decl: FUNCTION TYPE IDENTIFIER LPAREN params • RPAREN LBRACE $@14 statement_list RBRACE

    RPAREN  shift, and go to state 179


State 167

  131 params: param_list •
  132 param_list: param_list • COMMA param

    COMMA  shift, and go to state 180

    $default  reduce using rule 131 (params)


State 168

  133 param_list: param •

    $default  reduce using rule 133 (param_list)


State 169

  135 const_decl: CONST TYPE IDENTIFIER ASSIGN expression •

    $default  reduce using rule 135 (const_decl)


State 170

  128 argument_list: argument_list COMMA expression •

    $default  reduce using rule 128 (argument_list)


State 171

   41 if_stmt: IF LPAREN expression RPAREN @1 LBRACE • $@2 statement_list RBRACE $@3 else_part

    $default  reduce using rule 39 ($@2)

    $@2  go to state 181


State 172

  122 repeat_stmt: REPEAT LBRACE @13 statement_list RBRACE UNTIL • LPAREN expression RPAREN SEMI

    LPAREN  shift, and go to state 182


State 173

   52 while_stmt: WHILE @5 LPAREN expression RPAREN @6 • LBRACE $@7 statement_list RBRACE

    LBRACE  shift, and go to state 183


State 174

   64 for_stmt_declaration: TYPE IDENTIFIER ASSIGN error •

    $default  reduce using rule 64 (for_stmt_declaration)


State 175

   60 for_stmt_declaration: TYPE IDENTIFIER ASSIGN expression •

    $default  reduce using rule 60 (for_stmt_declaration)


State 176

   53 for_stmt: FOR LPAREN for_header SEMI expression SEMI • assignment RPAREN for_body
   55         | FOR LPAREN for_header SEMI expression SEMI • assignment error

    IDENTIFIER  shift, and go to state 184
    INC         shift, and go to state 17
    DEC         shift, and go to state 18

    assignment  go to state 185


State 177

   72 switch_stmt: SWITCH LPAREN IDENTIFIER RPAREN @9 LBRACE • $@10 case_list default_case RBRACE

    $default  reduce using rule 71 ($@10)

    $@10  go to state 186


State 178

  134 param: TYPE IDENTIFIER •

    $default  reduce using rule 134 (param)


State 179

  124 function_decl: FUNCTION TYPE IDENTIFIER LPAREN params RPAREN • LBRACE $@14 statement_list RBRACE

    LBRACE  shift, and go to state 187


State 180

  132 param_list: param_list COMMA • param

    TYPE  shift, and go to state 165

    param  go to state 188


State 181

   41 if_stmt: IF LPAREN expression RPAREN @1 LBRACE $@2 • statement_list RBRACE $@3 else_part

    $default  reduce using rule 2 (statement_list)

    statement_list  go to state 189


State 182

  122 repeat_stmt: REPEAT LBRACE @13 statement_list RBRACE UNTIL LPAREN • expression RPAREN SEMI

    NOT         shift, and go to state 40
    MINUS       shift, and go to state 41
    LPAREN      shift, and go to state 42
    INT         shift, and go to state 43
    FLOAT       shift, and go to state 44
    CHAR        shift, and go to state 45
    BOOLEAN     shift, and go to state 46
    IDENTIFIER  shift, and go to state 47
    STRING      shift, and go to state 48

    expression           go to state 190
    logical_expr         go to state 50
    logical_term         go to state 51
    equality_expr        go to state 52
    relational_expr      go to state 53
    additive_expr        go to state 54
    multiplicative_expr  go to state 55
    exponent_expr        go to state 56
    unary_expr           go to state 57
    primary_expr         go to state 58
    function_call        go to state 59


State 183

   52 while_stmt: WHILE @5 LPAREN expression RPAREN @6 LBRACE • $@7 statement_list RBRACE

    $default  reduce using rule 51 ($@7)

    $@7  go to state 191


State 184

   32 assignment: IDENTIFIER • INC
   33           | IDENTIFIER • DEC
   36           | IDENTIFIER • ASSIGN expression
   37           | IDENTIFIER • ASSIGN error

    ASSIGN  shift, and go to state 66
    INC     shift, and go to state 68
    DEC     shift, and go to state 69


State 185

   53 for_stmt: FOR LPAREN for_header SEMI expression SEMI assignment • RPAREN for_body
   55         | FOR LPAREN for_header SEMI expression SEMI assignment • error

    error   shift, and go to state 192
    RPAREN  shift, and go to state 193


State 186

   72 switch_stmt: SWITCH LPAREN IDENTIFIER RPAREN @9 LBRACE $@10 • case_list default_case RBRACE

    $default  reduce using rule 76 (case_list)

    case_list  go to state 194


State 187

  124 function_decl: FUNCTION TYPE IDENTIFIER LPAREN params RPAREN LBRACE • $@14 statement_list RBRACE

    $default  reduce using rule 123 ($@14)

    $@14  go to state 195


State 188

  132 param_list: param_list COMMA param •

    $default  reduce using rule 132 (param_list)


State 189

    3 statement_list: statement_list • statement
   41 if_stmt: IF LPAREN expression RPAREN @1 LBRACE $@2 statement_list • RBRACE $@3 else_part

    IF          shift, and go to state 4
    REPEAT      shift, and go to state 5
    WHILE       shift, and go to state 6
    FOR         shift, and go to state 7
    SWITCH      shift, and go to state 8
    FUNCTION    shift, and go to state 9
    RETURN      shift, and go to state 10
    CONST       shift, and go to state 11
    BREAK       shift, and go to state 12
    CONTINUE    shift, and go to state 13
    LBRACE      shift, and go to state 14
    RBRACE      shift, and go to state 196
    IDENTIFIER  shift, and go to state 15
    TYPE        shift, and go to state 16
    INC         shift, and go to state 17
    DEC         shift, and go to state 18

    statement      go to state 19
    declaration    go to state 20
    assignment     go to state 21
    if_stmt        go to state 22
    while_stmt     go to state 23
    for_stmt       go to state 24
    switch_stmt    go to state 25
    return_stmt    go to state 26
    repeat_stmt    go to state 27
    function_decl  go to state 28
    function_call  go to state 29
    const_decl     go to state 30


State 190

  122 repeat_stmt: REPEAT LBRACE @13 statement_list RBRACE UNTIL LPAREN expression • RPAREN SEMI

    RPAREN  shift, and go to state 197


State 191

   52 while_stmt: WHILE @5 LPAREN expression RPAREN @6 LBRACE $@7 • statement_list RBRACE

    $default  reduce using rule 2 (statement_list)

    statement_list  go to state 198


State 192

   55 for_stmt: FOR LPAREN for_header SEMI expression SEMI assignment error •

    $default  reduce using rule 55 (for_stmt)


State 193

   53 for_stmt: FOR LPAREN for_header SEMI expression SEMI assignment RPAREN • for_body

    LBRACE  shift, and go to state 199

    for_body  go to state 200


State 194

   72 switch_stmt: SWITCH LPAREN IDENTIFIER RPAREN @9 LBRACE $@10 case_list • default_case RBRACE
   77 case_list: case_list • case_item

    CASE     shift, and go to state 201
    DEFAULT  shift, and go to state 202

    $default  reduce using rule 85 (default_case)

    case_item     go to state 203
    default_case  go to state 204


State 195

  124 function_decl: FUNCTION TYPE IDENTIFIER LPAREN params RPAREN LBRACE $@14 • statement_list RBRACE

    $default  reduce using rule 2 (statement_list)

    statement_list  go to state 205


State 196

   41 if_stmt: IF LPAREN expression RPAREN @1 LBRACE $@2 statement_list RBRACE • $@3 else_part

    $default  reduce using rule 40 ($@3)

    $@3  go to state 206


State 197

  122 repeat_stmt: REPEAT LBRACE @13 statement_list RBRACE UNTIL LPAREN expression RPAREN • SEMI

    SEMI  shift, and go to state 207


State 198

    3 statement_list: statement_list • statement
   52 while_stmt: WHILE @5 LPAREN expression RPAREN @6 LBRACE $@7 statement_list • RBRACE

    IF          shift, and go to state 4
    REPEAT      shift, and go to state 5
    WHILE       shift, and go to state 6
    FOR         shift, and go to state 7
    SWITCH      shift, and go to state 8
    FUNCTION    shift, and go to state 9
    RETURN      shift, and go to state 10
    CONST       shift, and go to state 11
    BREAK       shift, and go to state 12
    CONTINUE    shift, and go to state 13
    LBRACE      shift, and go to state 14
    RBRACE      shift, and go to state 208
    IDENTIFIER  shift, and go to state 15
    TYPE        shift, and go to state 16
    INC         shift, and go to state 17
    DEC         shift, and go to state 18

    statement      go to state 19
    declaration    go to state 20
    assignment     go to state 21
    if_stmt        go to state 22
    while_stmt     go to state 23
    for_stmt       go to state 24
    switch_stmt    go to state 25
    return_stmt    go to state 26
    repeat_stmt    go to state 27
    function_decl  go to state 28
    function_call  go to state 29
    const_decl     go to state 30


State 199

   59 for_body: LBRACE • $@8 statement_list RBRACE

    $default  reduce using rule 58 ($@8)

    $@8  go to state 209


State 200

   53 for_stmt: FOR LPAREN for_header SEMI expression SEMI assignment RPAREN for_body •

    $default  reduce using rule 53 (for_stmt)


State 201

   79 case_item: CASE • CONSTANT_VAL COLON @11 statement_list
   80          | CASE • CONSTANT_VAL error
   81          | CASE • error

    error       shift, and go to state 210
    INT         shift, and go to state 211
    FLOAT       shift, and go to state 212
    BOOLEAN     shift, and go to state 213
    IDENTIFIER  shift, and go to state 214

    CONSTANT_VAL  go to state 215


State 202

   83 default_case: DEFAULT • COLON $@12 statement_list
   84             | DEFAULT • error

    error  shift, and go to state 216
    COLON  shift, and go to state 217


State 203

   77 case_list: case_list case_item •

    $default  reduce using rule 77 (case_list)


State 204

   72 switch_stmt: SWITCH LPAREN IDENTIFIER RPAREN @9 LBRACE $@10 case_list default_case • RBRACE

    RBRACE  shift, and go to state 218


State 205

    3 statement_list: statement_list • statement
  124 function_decl: FUNCTION TYPE IDENTIFIER LPAREN params RPAREN LBRACE $@14 statement_list • RBRACE

    IF          shift, and go to state 4
    REPEAT      shift, and go to state 5
    WHILE       shift, and go to state 6
    FOR         shift, and go to state 7
    SWITCH      shift, and go to state 8
    FUNCTION    shift, and go to state 9
    RETURN      shift, and go to state 10
    CONST       shift, and go to state 11
    BREAK       shift, and go to state 12
    CONTINUE    shift, and go to state 13
    LBRACE      shift, and go to state 14
    RBRACE      shift, and go to state 219
    IDENTIFIER  shift, and go to state 15
    TYPE        shift, and go to state 16
    INC         shift, and go to state 17
    DEC         shift, and go to state 18

    statement      go to state 19
    declaration    go to state 20
    assignment     go to state 21
    if_stmt        go to state 22
    while_stmt     go to state 23
    for_stmt       go to state 24
    switch_stmt    go to state 25
    return_stmt    go to state 26
    repeat_stmt    go to state 27
    function_decl  go to state 28
    function_call  go to state 29
    const_decl     go to state 30


State 206

   41 if_stmt: IF LPAREN expression RPAREN @1 LBRACE $@2 statement_list RBRACE $@3 • else_part

    ELSE  shift, and go to state 220

    $default  reduce using rule 48 (else_part)

    else_part  go to state 221


State 207

  122 repeat_stmt: REPEAT LBRACE @13 statement_list RBRACE UNTIL LPAREN expression RPAREN SEMI •

    $default  reduce using rule 122 (repeat_stmt)


State 208

   52 while_stmt: WHILE @5 LPAREN expression RPAREN @6 LBRACE $@7 statement_list RBRACE •

    $default  reduce using rule 52 (while_stmt)


State 209

   59 for_body: LBRACE $@8 • statement_list RBRACE

    $default  reduce using rule 2 (statement_list)

    statement_list  go to state 222


State 210

   81 case_item: CASE error •

    $default  reduce using rule 81 (case_item)


State 211

   66 CONSTANT_VAL: INT •

    $default  reduce using rule 66 (CONSTANT_VAL)


State 212

   67 CONSTANT_VAL: FLOAT •

    $default  reduce using rule 67 (CONSTANT_VAL)


State 213

   68 CONSTANT_VAL: BOOLEAN •

    $default  reduce using rule 68 (CONSTANT_VAL)


State 214

   69 CONSTANT_VAL: IDENTIFIER •

    $default  reduce using rule 69 (CONSTANT_VAL)


State 215

   79 case_item: CASE CONSTANT_VAL • COLON @11 statement_list
   80          | CASE CONSTANT_VAL • error

    error  shift, and go to state 223
    COLON  shift, and go to state 224


State 216

   84 default_case: DEFAULT error •

    $default  reduce using rule 84 (default_case)


State 217

   83 default_case: DEFAULT COLON • $@12 statement_list

    $default  reduce using rule 82 ($@12)

    $@12  go to state 225


State 218

   72 switch_stmt: SWITCH LPAREN IDENTIFIER RPAREN @9 LBRACE $@10 case_list default_case RBRACE •

    $default  reduce using rule 72 (switch_stmt)


State 219

  124 function_decl: FUNCTION TYPE IDENTIFIER LPAREN params RPAREN LBRACE $@14 statement_list RBRACE •

    $default  reduce using rule 124 (function_decl)


State 220

   46 else_part: ELSE • LBRACE $@4 statement_list RBRACE
   47          | ELSE • if_stmt

    IF      shift, and go to state 4
    LBRACE  shift, and go to state 226

    if_stmt  go to state 227


State 221

   41 if_stmt: IF LPAREN expression RPAREN @1 LBRACE $@2 statement_list RBRACE $@3 else_part •

    $default  reduce using rule 41 (if_stmt)


State 222

    3 statement_list: statement_list • statement
   59 for_body: LBRACE $@8 statement_list • RBRACE

    IF          shift, and go to state 4
    REPEAT      shift, and go to state 5
    WHILE       shift, and go to state 6
    FOR         shift, and go to state 7
    SWITCH      shift, and go to state 8
    FUNCTION    shift, and go to state 9
    RETURN      shift, and go to state 10
    CONST       shift, and go to state 11
    BREAK       shift, and go to state 12
    CONTINUE    shift, and go to state 13
    LBRACE      shift, and go to state 14
    RBRACE      shift, and go to state 228
    IDENTIFIER  shift, and go to state 15
    TYPE        shift, and go to state 16
    INC         shift, and go to state 17
    DEC         shift, and go to state 18

    statement      go to state 19
    declaration    go to state 20
    assignment     go to state 21
    if_stmt        go to state 22
    while_stmt     go to state 23
    for_stmt       go to state 24
    switch_stmt    go to state 25
    return_stmt    go to state 26
    repeat_stmt    go to state 27
    function_decl  go to state 28
    function_call  go to state 29
    const_decl     go to state 30


State 223

   80 case_item: CASE CONSTANT_VAL error •

    $default  reduce using rule 80 (case_item)


State 224

   79 case_item: CASE CONSTANT_VAL COLON • @11 statement_list

    $default  reduce using rule 78 (@11)

    @11  go to state 229


State 225

   83 default_case: DEFAULT COLON $@12 • statement_list

    $default  reduce using rule 2 (statement_list)

    statement_list  go to state 230


State 226

   46 else_part: ELSE LBRACE • $@4 statement_list RBRACE

    $default  reduce using rule 45 ($@4)

    $@4  go to state 231


State 227

   47 else_part: ELSE if_stmt •

    $default  reduce using rule 47 (else_part)


State 228

   59 for_body: LBRACE $@8 statement_list RBRACE •

    $default  reduce using rule 59 (for_body)


State 229

   79 case_item: CASE CONSTANT_VAL COLON @11 • statement_list

    $default  reduce using rule 2 (statement_list)

    statement_list  go to state 232


State 230

    3 statement_list: statement_list • statement
   83 default_case: DEFAULT COLON $@12 statement_list •

    IF          shift, and go to state 4
    REPEAT      shift, and go to state 5
    WHILE       shift, and go to state 6
    FOR         shift, and go to state 7
    SWITCH      shift, and go to state 8
    FUNCTION    shift, and go to state 9
    RETURN      shift, and go to state 10
    CONST       shift, and go to state 11
    BREAK       shift, and go to state 12
    CONTINUE    shift, and go to state 13
    LBRACE      shift, and go to state 14
    IDENTIFIER  shift, and go to state 15
    TYPE        shift, and go to state 16
    INC         shift, and go to state 17
    DEC         shift, and go to state 18

    $default  reduce using rule 83 (default_case)

    statement      go to state 19
    declaration    go to state 20
    assignment     go to state 21
    if_stmt        go to state 22
    while_stmt     go to state 23
    for_stmt       go to state 24
    switch_stmt    go to state 25
    return_stmt    go to state 26
    repeat_stmt    go to state 27
    function_decl  go to state 28
    function_call  go to state 29
    const_decl     go to state 30


State 231

   46 else_part: ELSE LBRACE $@4 • statement_list RBRACE

    $default  reduce using rule 2 (statement_list)

    statement_list  go to state 233


State 232

    3 statement_list: statement_list • statement
   79 case_item: CASE CONSTANT_VAL COLON @11 statement_list •

    IF          shift, and go to state 4
    REPEAT      shift, and go to state 5
    WHILE       shift, and go to state 6
    FOR         shift, and go to state 7
    SWITCH      shift, and go to state 8
    FUNCTION    shift, and go to state 9
    RETURN      shift, and go to state 10
    CONST       shift, and go to state 11
    BREAK       shift, and go to state 12
    CONTINUE    shift, and go to state 13
    LBRACE      shift, and go to state 14
    IDENTIFIER  shift, and go to state 15
    TYPE        shift, and go to state 16
    INC         shift, and go to state 17
    DEC         shift, and go to state 18

    $default  reduce using rule 79 (case_item)

    statement      go to state 19
    declaration    go to state 20
    assignment     go to state 21
    if_stmt        go to state 22
    while_stmt     go to state 23
    for_stmt       go to state 24
    switch_stmt    go to state 25
    return_stmt    go to state 26
    repeat_stmt    go to state 27
    function_decl  go to state 28
    function_call  go to state 29
    const_decl     go to state 30


State 233

    3 statement_list: statement_list • statement
   46 else_part: ELSE LBRACE $@4 statement_list • RBRACE

    IF          shift, and go to state 4
    REPEAT      shift, and go to state 5
    WHILE       shift, and go to state 6
    FOR         shift, and go to state 7
    SWITCH      shift, and go to state 8
    FUNCTION    shift, and go to state 9
    RETURN      shift, and go to state 10
    CONST       shift, and go to state 11
    BREAK       shift, and go to state 12
    CONTINUE    shift, and go to state 13
    LBRACE      shift, and go to state 14
    RBRACE      shift, and go to state 234
    IDENTIFIER  shift, and go to state 15
    TYPE        shift, and go to state 16
    INC         shift, and go to state 17
    DEC         shift, and go to state 18

    statement      go to state 19
    declaration    go to state 20
    assignment     go to state 21
    if_stmt        go to state 22
    while_stmt     go to state 23
    for_stmt       go to state 24
    switch_stmt    go to state 25
    return_stmt    go to state 26
    repeat_stmt    go to state 27
    function_decl  go to state 28
    function_call  go to state 29
    const_decl     go to state 30


State 234

   46 else_part: ELSE LBRACE $@4 statement_list RBRACE •

    $default  reduce using rule 46 (else_part)
